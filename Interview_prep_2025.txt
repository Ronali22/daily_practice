interview prep:-
====================

1. Core Java(OOPS Concept, Multithreading, exception, java8 features, collection)
2. Hibernate
3. Spring(Spring web, ORM, JEE, SPRING Core, AOP, JDBC)
4. Spring boot
5. Microservices(Eureka Server, API Gateway, Config server, Admin server, Zipkin and sleuth, Communication)
6. SQL Queries
7. GIT
8. Spring Security

JAVA:-
============

JVM Architecture:
-----------------
->It's a run time engine, responsible to run java based applications.
->It has two main tasks.
  1.load .class file
  2.execute .class file
->JVM Architecture contains 5 components.
1.Class Loader:
----------------
-> it used to load class files.
-> it is responsible for 3 tasks. a. loading, b. linking, c. initialization
2. Memory Areas:
-----------------
-> it has 5 types of memory areas.
	a. method area
	b. heap area(scp present inside thihs known as meta space)
	c. stack area
	d. pc register
	e. native method area
3. Execution engine:
---------------------
-> it contains 3 components.
	a.interpreter
	b. JIT compiler
	c. garbage collector/security manager
4. java native interfaces
5. native method libraries

static vs nonstatic.
Static:
->Defined within a class by using static keyword.
->Static is also known as class variable.
->Memory allocated at the time of class is loaded.
->Can be referred using class name or object reference.(object reference is not preferred.)
Non-static:
->Defined within a class without using static keyword.
->Non-Static is also known as  instance variable.
->Memory allocated at the time of object is created.
->Can be referred using object reference only.

What are JVM,JRE and JDK.
Ans: ->JDK:Java Development Kit.
     ->JDK is a complete software package which has every tools for development of a java program.
     ->JDK has JRE,JAR tools,compiler,Debugger etc..
     ->JRE:Java Runtime Environment
     ->JRE contains JVM & standard Runtime Libraries.
     ->JRE is a part of JDK, which provides a platform to execute java application.
     ->JVM: Java Virtual Machine
     ->JVM executes the byte code.
     ->JVM has the class loader,JIT compiler(Just In Time Complier),garbage collector
     ->It is a runtime instance which is created when we run the java class.

How does Java achieve platform independence?
Ans: ->When we create a java progarm, source code compiled into byte code by JVM and it generate a .class file.
     ->This .class file, we can run it in any operating system.Exa:Linux,IOS,WINDOWS
     ->This is why Java is known as platform independent.Java follows WORA(Write Once Read Anywhere).

String:
-------
-> in java String is a class.
-> we can create a String using different ways, 1. using new keyword, 2. by string literals
ex: String s1 = new String("car");//new keyword
    String s2 = "bike";//literals
Q. Why String is immutable in Java?
->When we create a string using new keyword, it will create string object in HeapMemory as well as SCP(String Constant Pool).
->When we create a string using literal, it will create string object only in SCP.
->When we try to create another string using literal, it will check in SCP, whether it is already present or not.
  If it is present, then the variable will point towards existing object. So, if we try to change the value, then other variable also get affected as all are pointing towards same object.
-> similarly when we try to create string object using new keyword, it will create new object every time even if the string value is same.
thats why string is immmutable in java.

OOPS[object oriented programming]
----------------------------------
Note: 
* variables=>properties, fields
* methods=>behaviours, functions
* in java every classes extends Object class by default.

1.Inheritance
--------------
->Acquiring properties from parent class to child class.
-> type
a. single inheritance-> one parent and one child class
b. multiple inheritance-> not supported (in terms of classes not supported, in terms interface supported)
c. multilevel inheritance-> one child, one parent, one grand parent class...... and so on
d. cyclic inheritance-> inter dependent classes
=> in terms of classes, java doesnot support multiple inheritance. it causes diamond problem thats why.
diamond problem: as object class is parent of every other class, when we create a child class named Vehicle, which extends two parent classes as Car, Bike.
                 Both parent classes are having a method as start(). in this scenario the java compiler will get confuse which start() method to be called.

2.Polymorphism
----------------
-> same name but different behaviour
example:- 
public int add(int a, int b){return a+b;}
public String add(String a, String b){return a+b;}
-> types
a. Compile time polymorphism-> method overloading( in same class, multiple methods with same name and different arguments)
b. Run time polymorphism-> Method overriding (in different class, multiple methods with same name and same arguments)

3.Abstraction
--------------
-> Hiding unwanted implementation and providing useful methods.
-> By using abstract classes and interfaces we can achieve abstraction.
-> If a class contains atleast one abstract method, then that class is known as abstract class.
->Abstract method- a method without implementation is known as abstract method. ex: public void engineStart();

4.Encapsulation
----------------
-> Binding properties and behaviours in a single unit.
-> To achieve encapsulation we have to declare all the properties/variables/fields as 'private' and to access those we have to provide public methods, known as setters and getters.

-----------------------------------------------------------------------------------------------------------------

Example of

1. Inheritance
----------------

class Vehicle{
 	String type;
 	int identficationNumber;
}

class Car extends Vehicle{
	String company;
}

class Tata{
}
public class InheritanceExample{
	public static void main(String[]args){
		Vehicle v=new Car();
		car c= (Car) v;
	sout.println(c.company);

}
}

2. Abstraction
----------------

package com.InterviewPractice;
abstract class Animal{

	String animalType;

	public void wildAnimal(){
	
	System.out.println("wild animal spotted");

	}

	public void domesticAnimal(){
	
	System.out.println("domestic animal spotted");

	}
	
	abstract public String animalStructure();

}

class Dog extends Animal{
	private int legs;

	public void wildAnimal(){
	
	System.out.println("wild animal spotted");
	}
	
	public String animalBehavior(){
		
		System.out.println("animals barking");
		return "animalBehavior";
	}
	@Override
	public String animalStructure() {
		System.out.println("abcd");
		return "animalStructure`";
	};

}
public class Abstracton {
	public static void main(String args[]){
	Animal a1=new Dog();
	a1.domesticAnimal();
	a1.wildAnimal();
	System.out.println("-----");

}
}

3. Encapsulation:
-----------------
package com.InterviewPractice;

class Bank{
	private String userName;
	private int userId;
	private String userAddress;
	
	public void setUserName(String name) {
		this.userName=name; //this keyword is used to refer same class non static variable.
	};
	public void setUserId(int id) {
		this.userId=id;
	}
	public void setUserAddress(String add) {
		this.userAddress=add;
	}

	public String getUserName() {
		return userName;
	}
	public int getUserId() {
		return userId;
	}
	public String getUserAddress() {
		return userAddress;
	}
	public String toString() {
		return userName+" "+userId+" "+userAddress;
	}
}
public class Encapsulation {
	public static void main(String[]args) {
		Bank bank=new Bank();
		bank.setUserName("Raju");
		bank.setUserId(2024);
		bank.setUserAddress("bbsr");
		System.out.print(bank);;
		
//		System.out.println(bank.getUserName());
//		System.out.println(bank.getUserId());
//		System.out.println(bank.getUserAddress());
	}
}

4.Polymorphism:
---------------
package com.InterviewPractice;

//note- resolving method call at compile time is known as compile time polymorphism.
// resolving method call at run time is known as run time polymorphism.
class Watch{
	void digital() {
		System.out.println("buying digital watch");
	}
	void digital(int a) {
		System.out.println("buying two "+a+" set digital watch");
	}
}
class DigitalWatch extends Watch{
	@Override
	void digital() {
		System.out.println("buying new digital watch");
	}
}
public class Polymorphism {

	public static void main(String[] args) {
		Watch w=new Watch();
		w.digital();
		w.digital(2);
		
		DigitalWatch d=new DigitalWatch();
		d.digital(); 

	}

}


Exception Handling:
-------------------
-> Unwanted termination/abroption of program during normal execution is known as exception.

Types:
------
1.Unchecked exception/Run-time exception
----------------------------------------
-> The exception which can't be checked by compiler at compile time.
-> ex: ArithmaticException, NullPointerException, IndexOutOfBoundException, ClassCastException

2.Checked exception/Compile-time exception
------------------------------------------
-> The exception which can be checked by compiler at compile time.
-> ex: ClassNotFoundException, IOException(FileNotFoundException, InterruptedIOException), SQLException

--> Exception can be handlled using 1. try........catch block 2. throw and throws 3.finally block

example:1
---------------
try...catch block
----------------------
class Math {
public static void main(String[] args) {
      int a = 100;
      int b = 0;
try{
      int c = a/b;
      System.out.println(c);
} catch (Exception e) {
      System.out.println(c);
}
}
}
example:2
---------------
package com.InterviewPractice.exception;

public class ExceptionHandlingExample {

	public static void main(String[] args) {
		int a = 100;
		int b = 0;
		int c = 0;
//		try {
//			c = a / b;// risky code
//		} catch (ArithmeticException e) {
//			System.out.println("inside ArithmeticException's catch block");
//		} catch (Exception e) {
//			System.out.println("inside Exception's catch block");
//			c = c + 15;
//		} finally {
//			System.out.println("thank you");
//		}
		try {
			c = a / b;// risky code
		} catch (ArithmeticException | NullPointerException e) {//multiple exceptions can be present inn a single catch byusing "or" operator.
			System.out.println("inside catch block");
		} finally {
			System.out.println("thank you");
		}
		System.out.println(c);
		System.out.println("working");
	}

}
note: multiple catch with a single try block can be written. but the exceptions should be handled from child to parent type.

throw..........throws keyword:
-------------------------------
-> throw is used to create new exception where as throws is used to declare an exception.

example:3
-----------------
package com.InterviewPractice.exception;

//checked exception example
class DemoException extends Exception {
	DemoException() {// constructor
		System.out.println("car exception occured");
	}

	DemoException(String msg) {
		System.out.println(msg);
	}
}

//unchecked exception example
class Demo2Exception extends RuntimeException {
	Demo2Exception() {// constructor
		System.out.println("car exception occured");
	}

	Demo2Exception(String msg) {
		System.out.println(msg);
	}
}

public class ThrowAndThrowsExample {
	public static int division(int a, int b) throws DemoException{
		return a / b;
	}

	public static void main(String[] args) {
		int a = 100;
		int b = 0;
		try {
			if (b == 0) {
				throw new Demo2Exception("exception occured");
			}
			int result = division(a, b);
			System.out.println(result);

		} catch (DemoException | Demo2Exception e) {
			System.out.println("inside catch block");
		}
		System.out.println("abc");
		System.out.println("abc");
		System.out.println("abc");
		System.out.println("abc");
	}
}
---------------------------------------------------------------
multithreading:
------------------
-> in programming we are having multi tasking. this can be of two types. 
1. multiprocess: multiple processes like playing video on vlc media, working on ide, listening music etc we can do simultaneously. this is know to be multiprocess
	process: process ia an independent task. its is having its own resources and memory. example:vlc media, working on ide, listening music etc
2. multithreading:Multithreading is a process of execution of more than one thread at a time or simulateneously.
->In multithreading threads are sharing a common resource or memory.
-> thread can be created in 2 ways.
1. by extending Thread class
2. by implementing Runnable interface

Thread: thread is an independent path of execution. thread is a light weight process. Thread class is present inside java.lang package.

-> A thread can not be started more than once. if we try to do so then it will throw IllegalThreadStateException.
Types of thread:
----------------
1. Deamon thread:
	-> these are low priority threads which performs low priority tasks like checking for updates, maintaining history/backups etc..
	-> JVM does not give much importance to these types of threads.
2. non deamon thread:
	-> these are high priority tasks used to carry the main tasks. JVM gives much importance to it.example: main thread in an java programm(refers to main method)
-> by default a thread is deamon or non deamon that is depends on parent thread. if parent thread is deamon then child thread will also be a deamon thread.
-> we can set a thread as deamon by using "setDeamon() as true".
-> we should set the thread as deamon or nondeamon before starting it.
Thread priority:
---------------
-> every thread has priority level. it veries from 1 to 10. 1 means low 10 means high.
-> based on the priority of a thread, thread scheduler schedules the thread execution.
-> by default a thread priority is same as the parent thread's priority.
-> main threads priority is 5.
-> we can set a threads priority by using setPriority() method.

example:1
-----------
package com.InterviewPractice.multithread;

//String userName;//varibale
//String userName();//abstract method
//String userName(){};//concrete method
//new UserName();//class obejct creation

class MyThread1 extends Thread{//creating thread using Thread class
	public void run() {
		for(int i = 1; i<=100;i++) {
			System.out.println(i);
		}
	}
}

class MyThread2 implements Runnable{//creating thread using Runnable interface

	@Override
	public void run() {
		for(int i = 1001; i<=1100;i++) {
			System.out.println(i);
		}
	}
	
}

public class MultithreadingExample {
	public static void main(String[] args) {
		MyThread1 t1 = new MyThread1();
		t1.start();
		
		MyThread2 t2 = new MyThread2();
		Thread myThread = new Thread(t2);
		myThread.start();
		
	}
}
------------------------------------------------------------
Collections Framework:
------------------------
1. List:
---------
(i) ArrayList:
--------------
-> It is a list implementation class.
-> it follows array representation.
->it allows duplicate elements as it implements list interface.

package com.InterviewPractice.collection;

import java.util.*;

public class ArrayListEx {

	public static void main(String[] args) {
		ArrayList <Integer> al=new ArrayList<>();
		al.add(15);
		al.add(65);
		al.add(58);
		al.add(76);
		System.out.println(al);
	}

}

(ii) LinkedList:
-----------------
-> It is a list implementation class.
-> it follows linked representation.
-> it allows duplicate elements as it implements list interface.
-> stores elements in insertion order.

package com.InterviewPractice.collection;

import java.util.*;

public class LinkedListEx {
	
	public static void main(String[] args) {
		LinkedList <Integer> ll=new LinkedList<>();
		ll.add(25);
		ll.add(64);
		ll.add(51);
		ll.add(88);
		System.out.println(ll);
	}

}

2. Set:
--------
(i) HashSet:
------------
-> it is an implementation of hashing technique with array representation.
-> it doesnot allow duplicate elements as it implements set interface.
-> it's an unordered set because here insertion order is not preserved.

Hashing:
---------
-> it is a technique which allows insertion, deletion and find operations in a constant average time.

package com.InterviewPractice.collection;

import java.util.*;

public class HashSetEx {

	public static void main(String[] args) {
		HashSet <Integer> hs=new HashSet<>();
		hs.add(50);
		hs.add(65);
		hs.add(47);
		hs.add(15);
		System.out.println(hs);

	}

}

(ii) LinkedHashSet:
---------------------
-> It is an implementation of hashing technique with linked representation.
-> Here, insertion, deletion order is preserved because it is an ordered set.
-> it doesnot allow duplicate elements because it implements set interface.

package com.InterviewPractice.collection;

import java.util.*;

public class LinkedHashSetEx {

	public static void main(String[] args) {
		LinkedHashSet <Integer> lhs=new LinkedHashSet<>();
		lhs.add(54);
		lhs.add(35);
		lhs.add(77);
		lhs.add(85);
		System.out.println(lhs);


	}

}

(iii) TreeSet:
---------------
-> It is an implementation of binary search tree technique with linked representation.
-> it doesn't allow duplicate values as it implemets list interface.
->all elements are sorted because it is a sorted set.

Binary search tree:
--------------------
->A binary tree said to be a binary search tree if it follows the following rules.
i. if the element is less than root element then it must be in left sub tree.
ii. if the element is greater than root element then it ust be in right sub tree.

package com.InterviewPractice.collection;

import java.util.*;

public class TreeSetEx {

	public static void main(String[] args) {
		TreeSet <Integer> ts=new TreeSet<>();
		ts.add(21);
		ts.add(89);
		ts.add(44);
		ts.add(82);
		System.out.println(ts);


	}

}

(3) Queue:
-----------
->it is an implementation of queue data structure.
->It follows FIFO principle
->it allows insertion in rear end only.
->it allows deletion in front end only.

(i) Priority Queue:
--------------------
-> in priority queue lease element is the highest priority.
-> it allows duplicate elements.
->Here offer() method is used to insert the elements and poll() method is used to delete the elements.
->here, insertion order is not preserved.

package com.InterviewPractice.collection;

import java.util.*;

public class PriorityQueueEx {

	public static void main(String[] args) {
		PriorityQueue <Integer> pq=new PriorityQueue<>();
		pq.offer(56);
		pq.offer(65);
		pq.offer(98);
		pq.offer(10);
		pq.offer(25);
		
		System.out.println(pq);
		System.out.println(pq.poll());
		System.out.println(pq);
		System.out.println(pq.poll());
		System.out.println(pq);

	}

}

(ii) Array Deque:
------------------
-> It is an implementation of double ended queue data structure with array representation.
-> it allows duplicate elements.
->it allows both insertiona and deletion at both the end, as it implemnts dequeu interface.

package com.InterviewPractice.collection;

import java.util.*;

public class ArrayDequeEx {

	public static void main(String[] args) {
		ArrayDeque <Integer> ad=new ArrayDeque<>();
		ad.add(20);
		ad.add(84);
		ad.add(49);
		ad.add(62);
		System.out.println(ad);
	}//

}

Interface:
-----------
-> in interface all the variable are by default public static final and methods are public abstract.
-> Every interface itself an abstract.
-> Interfaces can't be instantiated.
-> Interface can be inherited into a class by using implements keyword.
-> Interface can also be inherited into another inteface by using extends keyword.
-> Whenever interface is inherited then all abstract methods of an interface must be overridden in a sub class or sub class must be declared with abstract keyword otherwise compile time error occurs.
-> an interface can contain concrete methods known as default methods.
-> as default methods introduced in java 1.7, to provide support to the older versions, we have to provide "default" keyword as prefix to the concrete methods,
   this is known as "backward compatibility".

example:
================
package com.InterviewPractice;

interface Bike {
	void speedUp();//abstract method

	default void electricSupport() {//concrete method
		System.out.println("Electric support provided");
	}
}

interface ElectricBike {
	void roboticBike();
}

class Remote implements Bike, ElectricBike {//multiple inheritance
	@Override
	public void speedUp() {
		System.out.println("speed increased");
	}

	@Override
	public void roboticBike() {
		System.out.println("Robotic bike has started");
	}
}

public class Interface {

	public static void main(String[] args) {
		Remote r = new Remote();
		r.speedUp();
		r.electricSupport();//calling default method
		r.roboticBike();
		
	}

}
--------------------------------------------------------------------------------------------------------------------------------------------------------

Java 8 features:
----------------
1. new Date and Time api
2. Lambda expression
3. Functional interface
4. Stream API
5. Default methods in interface
6. Static methods in interface
7. Method reference
8. Constructor reference.
---------------------------------
1. Lambda expression:
--------------------
-> Lambda is an annonymous function.
-> it has no name, no accesss modifier, no return type.
->in java upto java 1.7, java was supporting only object oriented programming approach. then from java 1.8 onwards by the help of lambda expressions,
 functional interfaces, java supported "functional programming" approach.
->Functional Proframming- java 1.8 onwards, java supported functions as an argument to another function. This is known as functional programming.

example: 
public static void m1(){System.out.pritln("hello")}; => () -> System.out.println("hello");
public static int m2(int a, int b){return a+b}; => (a, b) -> a+b;
public static void m3(String name){System.out.pritln(name)}; => (name) -> System.out.println(name);

2. Functional interface:
-----------------------------
-> an interface which having only one abstract method is known as functional interface.
-> functional interface is used to invoke/call lambda expression.
-> Comprator is example of functional interface which gives us compare() method.

example:
package com.InterviewPractice.example;

//with lambda expression
@FunctionalInterface
interface Car{
	void startEngine();
}
public class LambdaExpressionExample {
	public static void main(String[] args) {
		Car c1 = ()->System.out.println("engine started");//here we are storing a function (i.e annonymous function/lambda expression) inside a variable.
		c1.startEngine();
		
	}

}
-----------------------------
-> java provided some predefined functional interfaces.
1. Predicate:test(T t)
2. Suplier:get()
3. Consumer:accept(T t)
4. Function: apply(T t)

example:
import java.util.function.Predicate;

//class PredicateDemo {
//	public boolean test(int i) {
//		if (i % 2 == 0))
//		else
//			return false;
//	}
//}

public class LambdaExpressionExample2 {
	
	public static void main(String[] args) {
//		PredicateDemo pd = new PredicateDemo();
//		boolean result = pd.test(5);
//		System.out.println(result);
		
		//by using lambda expression and functional interface
		 Predicate<Integer> p = i -> i % 2 == 0;
		 System.out.println(p.test(10));
	}
	
}
-------------------------
Method Reference:
-----------------
-> Instead of using lamda expression, we can also use method reference.

example:
package com.InterviewPractice.example;

import java.util.List;
import java.util.function.Predicate;

// WAP to print student names starting with A.
public class LambdaExpressionAndMethodReferenceExample3 {

	public static boolean checkName(String name) {
		if (name.charAt(0) == 'A')
			return true;
		else
			return false;
	}

	public static void main(String[] args) {
		List<String> sl = List.of("Akash", "Bikash", "Kailash", "Anil", "Amrut");
//		Predicate<String> p=name->name.charAt(0)== 'A';
		Predicate<String> p = LambdaExpressionAndMethodReferenceExample3::checkName;//on static context
		
//		LambdaExpressionExample3 le = new LambdaExpressionExample3();//on non-static context(remove static keyword from checkName)
//		Predicate<String> p = le::checkName;

		for (String studentName : sl) {
			if (p.test(studentName))
				System.out.println(studentName);
		}

	}

}
-------------------------
Stream API:
------------
-> from java 1.8 onwards stream api came into picture.
-> we use collection to store data and we use stream api to process the data.
-> stream api has two type of operation to perform. 
	1. intermediate funcitons: map(), filter(), flatmap() etc..
	2. terminal functions: max(), min(), count() etc..
-> stream is like a flow of data which can be preocessed once only.
-> stream does not change/modify the data present in the collection.
-> map(): if we want to perform any task on each and every elements present inside a collection then we can use map().
-> filter(): if we want to preform some filter operation on a collection of data then we can use filter().
-> a stream can be created in two ways. 
	1. Stream.of() 
	2. <collectionType>.stream(), example: list.stream()
example:
package com.InterviewPractice.revision;

import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

//1. WAP to filter female employee.
//2. WAP to increment salary by 20,000 for each employee
//3. WAP to filter employees whose salary is more than 20,000
//4. WAP to filter employees whose name starts with R
//5. WAP to filter employees whose salary is between 20000 to 40000
//6. WAP to count employees whose name starts with R
//7. WAP to find whose salary is maximum
//8. WAP to find whose salary is minimum
//9. WAP to sort the employees according to their salary in descending order

class Employee{
	private String employeeName;
	private String employeeGender;
	private double employeeSalary;
	
	public Employee(String employeeName, String employeeGender, double employeeSalary ){
		super();
		this.employeeName=employeeName;
		this.employeeGender=employeeGender;
		this.employeeSalary=employeeSalary;
	}
	public String getEmployeeName() {
		return employeeName;
	}
	public void setEmployeeName(String employeeName) {
		this.employeeName = employeeName;
	}
	public String getEmployeeGender() {
		return employeeGender;
	}
	public void setEmployeeGender(String employeeGender) {
		this.employeeGender = employeeGender;
	}
	public double getEmployeeSalary() {
		return employeeSalary;
	}
	public void setEmployeeSalary(double employeeSalary) {
		this.employeeSalary = employeeSalary;
	}
	@Override
	public String toString() {
		return "Employee [employeeName=" + employeeName + ", employeeGender=" + employeeGender + ", employeeSalary="
				+ employeeSalary + "]";
	}
	
}
public class Example1 {

	public static void main(String[] args) {
		
Employee employee1 = new Employee("Raju", "Male", 10000.00);
//System.out.println(employee1.getEmployeeGender());
Employee employee2 = new Employee("Sita", "Female", 20000.00);
Employee employee3 = new Employee("Hari", "Male", 30000.00);
Employee employee4 = new Employee("Gita", "Female", 60000.00);
Employee employee5 = new Employee("Mita", "Female", 50000.00);
Employee employee6 = new Employee("Rahul", "Male", 70000.00);

List<Employee> employeeList= List.of(employee1, employee2, employee3, employee4, employee5, employee6);

	//1.
	//List<Employee> result = employeeList.stream().filter(e->e.getEmployeeGender()=="Female").collect(Collectors.toList());
	//System.out.println(result);
	
	//2.
	//employeeList.stream().map(e->e.getEmployeeSalary()+20000.00).collect(Collectors.toList()).forEach(System.out::println);
	
	//3.
	//employeeList.stream().filter(e->e.getEmployeeSalary()>20000.00).collect(Collectors.toList()).forEach(System.out::println);
	
	//4.

//	employeeList.stream()
//			.filter(e->e.getEmployeeName().charAt(0)=='R')
//			.collect(Collectors.toList())
//			.forEach(System.out::println);;
	
	//5.
	
//	List<Employee> result = employeeList.stream()
//			.filter(e->(e.getEmployeeSalary()>20000.00 && e.getEmployeeSalary()<40000.00))
//			.collect(Collectors.toList());
	//System.out.println(result);
	
	//6.
//	long count  = employeeList.stream()
//			.filter(e->e.getEmployeeName().charAt(0)=='R')
//			.count();
	//System.out.println(count);
	
	//7. 
	//Employee employeeWithMaxSalary = employeeList.stream().max((a,b)->(int)(a.getEmployeeSalary()-b.getEmployeeSalary())).get();
	//System.out.println(employeeWithMaxSalary);
	
	//8. 
	//Employee employeeWithMinSalary = employeeList.stream().min((a,b)->(int)(a.getEmployeeSalary()-b.getEmployeeSalary())).get();
	//System.out.println(employeeWithMinSalary);
	
	//9.
	List<Employee> result = employeeList.stream()
			.sorted(Comparator.comparing(Employee::getEmployeeSalary).reversed())
			.collect(Collectors.toList());
	result.forEach(System.out::println);
	}
}
-------------------------------------------------------------
Optional class:
---------------
-> Optional classes used for handling null.
-> if a method returns null value, then might be possible the upcoming method may get
	fail and will throw nullpointer exception. so to prevent this we can use optional class.
example:
-------
package com.InterviewPractice.example;

import java.util.Optional;

class Employee {
	private String employeeName;
	private String employeeGender;
	private double employeeSalary;

	public Employee(String employeeName, String employeeGender, double employeeSalary) {
		super();
		this.employeeName = employeeName;
		this.employeeGender = employeeGender;
		this.employeeSalary = employeeSalary;
	}

	public static Optional<Employee> getEmployee(String employeeName, String employeeGender, double employeeSalary) {
		// assuming data base logic written below and its fetching data from db
		return Optional.of(new Employee(employeeName, employeeGender, employeeSalary));
	}

	@Override
	public String toString() {
		return "Employee [employeeName=" + employeeName + ", employeeGender=" + employeeGender + ", employeeSalary="
				+ employeeSalary + "]";
	}
}

public class OptionalClassExample {
	public static void main(String[] args) {

		Optional<Employee> optionalEmployee = Employee.getEmployee("ram", "male", 25000.00);
		if (optionalEmployee.isEmpty() || optionalEmployee.isPresent())
			System.out.println(optionalEmployee.get());// getting the actual employee object as final result by using get()
	}
}
------------------------------------------------------------
-> After completing core java, we have seen collection framework, going forward in advance java there are JDBC, hibernate,servlet,JSP.
->In JDBC we are establishing the connection between java and database and storing data. But there is a problem, data can be stored in the form of values.
-> Apart from this, few more problems are there with JDBC, which are known as ORM problems. Those are:
 1. Problem of Relations
 2. Problem of inheritance
 3. Problem of navigation
 4. problem of grain
 5. problem of identity
-> In ORM, one class will be mapped with one table. each column of table represents fields present inside class and each row represents ojbects. 
-> To overcome these problem JPA standards has been specified. Any solution providers has to follow these standards.
-> Different vendors provided their solution to overcome these ORM problems, like- Ibatis, topLink, hibernate
-> By using hibernate we can store objects into database.
->Servlets deals with web technology(old).
-> In JSP we can write java and html code in the same page.

SPRING FRAMEWORK:
--------------------
-> Framework provides us some predefined functionalities.
-> it's like a half developed project, which contains configurations, dependencies, methods, classes etc.. 
   which helps us to develop our application faster. Ex: Spring framework, hibernate framework
-> Spring framework contains. 1. AOP 2.JDBC 3.ORM 4.JEE 5.MVC(WEB) 6.Spring core (IOC and DI) modules.
-> By using spring framework, majorly web based applications can be developed.

SPRING CORE:
------------
-> It has IOC and DI concept.
->IOC- Inversion of Control. DI- Dependency Injection.
->IOC: Inverting(providing) the power of object creation from developer to spring container.
->DI(Dependency Injection): It refers to HAS-A relationship. One class has another classes object inside it, that means, 
	we will inject one class object into another class by using '@Autowired' annotation.(We can do it using xml configuration as well).
Note- Inheritance follows IS-A relationship where one class extends another class.
-> DI further divided into 3types.
	1. setter injection
	2. constructor injection -> by using xml configuration  => <constructor-args></constructor-args>
	3. field/property injection -> by using xml configuration  => <property></<property>
->Spring Core has spring container. It manages bean(objects inside spring container) life cycle.
->Spring Framework provides 2 containers.
 1. BeanFactory(old)(I)
 2. ApplicationContext (new) (I)

BeanFactory
-----------
-> supports xml configuration only.
-> It has one implementation class XmlBeanFactory(C).
->It also known as legacy container.
-> it supports simple java applications only.

ApplicationContext
-------------------
-> It supports all type of configuration.
Note: Spring framework suppoerts 3 types of configurations. 1.Xml 2.Java 3.Annotation
->It has multiple implementation classes.
Ex: 1.ClassPathXmlApplicationContext(C)
    2.FileSystemXmlApplicationContext(C)
    3.AnnotationConfigApplicationContext(C)
->Spring framework helps to develop applications in a faster way, known as Rapid application development.
->Less error rate.
->Reduces duplicate code by providing boiler plate code.
-> it supports imple java applications as well as web based applications.

SPRING WEB:
-----------
->It is used to develop web applications.
-> Spring web follows front controller design pattern. in this only one servlet will handle all type requests, and that servlet is known as dispathcher servlet.
-> when a users comes to login page, they will provide their credentials(username & password).
-> then a request object will be created and send to server. in server dispatcher servlet is present to accept that request.
-> further dispatcher servlet will extract the URL present inside that request object and send it to "Handler Mapping".
-> Handler Mapping contains all controllers name which are mapped with respective type of requests. example: login.html -> login.java
-> then Handler Mapping will send the appropriate controller name to dispatcher servlet.
-> further dispatcher servlet will send that request to respective "Controller".
-> then controller will processs the request and in response provides model object and view name and sends it to dispatcher servlet.
Note: Model object used to transefer the java object to view(html/jsp page).
-> again dispatcher servlet will send the view name to "View Resolver". View Resolver checks that view is present or not. if present then it will send that view
	to dispatcher servlet or else 404 error page will send to dispatcher servlet.
-> futher dispatcher servlet will return the response to user.
------------------------------------
Spring Boot:
------------
-> its based upon spring framework.
-> benifits of spring boot application over spring application,
	1. we dont have to add dependencies mannually from maven repository.
	2. no version mismatching of dependencies
	3. helps to develop application rapidly by providing boilerplate code(boilerplates refers to common codes used for project building)
	4. it provides starter dependencies(starter dependencies are multiple dependecies in a single bundle)
-> every java spring application has pom.xml file for maven applications, in case of gradle application its build.gradle file.
-> it contains all the dependencies which we require to develope the application.
-> there are different types of architectures we can follow to develope an enterprise level application. majorly layer based architecture we follow.
-> in "Layer Based Architecture" there can be many layers we can create as per our convenience but there are mainly 3 layers present in an application.
	1. Controller layer
	2. Service layer
	3. Repository layer

Annotations:
---------------------
@SpringBootApplication: its a combination of @ComponentScan, @Configuration, @EnableAutoConfiguration
@ComponentScan: its used to scan base packages for beans/objects
@EnableAutoConfiguration: its used to enable project configuration automatically by spring container
@Configuration: its used enable annotation based configuration
@Component: it used to declare a class as an spring object
@Bean: it used to create beans or objects.
@Controller: it used to declare a class as controller. Basically it used for controller layer.
@Service: it used to declare a class as service. Basically it used for service layer. it contains business logic.
@Repository: it used to declare a class as repository. Basically it used for repository layer. this layer directly deals with database.
@Autowired: it used for dependency injection.
@Entity: it used to make a class in entity. It maps class,fields with database table column.
@Table: it used to create a table name
@Id: it used to declare a field as primary key.(note: works only with integer/int type of id)
@GeneratedValue: it used to generate id automatically.
@Column: it written above fields to provide the column name or modified column name. 
@RestController: ReST + Controller => ReST(Representational state transfer) its an architecture. it deals with json objects(json=> javascript object notation). 
		it is used to transfer data via network. previously we were using XML to transfer data.(XML=> extensibile markup language)
		in web applications we use it to declare that the class is a controller which handles all type of web requests POST, GET, PATCH, DELETE etc..
@RequestMapping:it used to map a url to controller.We can povide the base url using it.
@PostMapping: it used for POST type url/endpoint. Generally we use it for insert operation.
@GetMapping: it used for GET type url/endpoint.Generally we use it for read operation.
@PutMapping: it used for PUT type url/endpoint.Generally we use it for update operation.
@PatchMapping:it used for PATCH type url/endpoint.Generally we use it for partial update operation.
@DeleteMapping:it used for DELETE type url/endpoint.Generally we use it for delete operation.
@Getter:it is used to generate getter methods.
@Setter:it is used to generate setter methods.
@ToString:it is used to print object.
@RequestBody:it is used to convert Json type object into userdefined object                                                                                          
@PathVariable:It is used to extract values from url                                                                                                                                                                                                                                                                                              
@RequestParam:it used to extract key value pairs fom url.
@Value: it is used to take user input from application properties file dynamically.
@Query: it is used to enable native query/sql query into our spring application.
ResponseEntity: it used to convert the reponse object into json type object.                                                                                               

Note:
------
method signature:
=========================
<access modifier> <return type> <mehod name>(method input arguments...){
	//method body
}

example:-

	normal/general method						method using lambda expression
-----------------------------------------------			------------------------------------------------------
public void print(String name1, String name2){		=>	(name1, name2) -> System.out.println(name1,name2);
	System.out.println(name1,name2);
}

example:
list.stream().filter(e->e.getEmployeeSalary()>20000.00).collect(Collectors.toList());

Task:
=====
//WAP to print how many female employees are there in the organization.
//WAP to print the name of all departments in the org
//WAP what is the average age of male and female employees in the org
//WAP to find the details of highest paid employee
//WAP to filter who has the most working exp in the org
//WAP to count the number of employees in each department.
//WAP to separate the employees who are younger or equal to 25 years and who are older than 25 years
//WAP to  filter the name of employees who joined after 2015.

1. list.stream().filter(e->e.getEmployeeGender()=="female").count
	sout.println("Number of female empoyees are:");
2.list.stream().map(e->e.getEmployeeDepartmentName()).collect(Collectors.toList()).forEach(System.out::println);
3.Double avgOfMale = list.stream().filter(e->e.getEmployeeGender()=="Male").collect(collectors.averagingInt(e->e.getEmployeeAge()));
  Double avgOfFemale = list.stream().filter(e->e.getEmployeeGender()=="Female").collect(collectors.averagingInt(e->e.getEmployeeAge()));
4.Emp maxSalary = employeeList.stream().max((a,b)->(int)(a.getEmployeeSalary()-b.getEmployeeSalary())).get();
                  System.out.println(maxSalary);
5.Emp workingExp = employeeList.stream().max((a,b)->b.getEmployeeYearOfJoining()-a.getEmployeeYearOfJoining())).get();
		System.out.println(workingExp);
7.employeeList.stream().filter(e->e.getEmployeeAge()<=25).collect(Collectors.toList()).forEach(System.out::println);
  employeeList.stream().filter(e->e.getEmployeeAge()>25).collect(Collectors.toList()).forEach(System.out::println);
8.employeeList.stream().filter(e->e.getEmployeeYearOfJoining()>2015).collect(Collectors.toList()).forEach(e->System.out.println(e));
=========================================================================================
Microserivce:
=============
-> Microservice, in other word its known as distributed application.
-> that means while a monolithic application contains all types of services in a single applcation, a microservice will create indivisual service to handle individual tasks.
-> these services will be interconnected.
for example:- Swiggy application contains different services like food ordering, tracking, payment, registration, security etc.
Microservice Architecture:
--------------------------
-> From front-end(client) user will send a http request which will come in json form to backend. in backend, server is there to receive the request.
-> here API Gateway will be the 1st service which will take the request. it works as a entry point or gate keeper to our microservice application.
-> then the request will go to eureka server. at eureka server it will get the microservice details associated with that request. then it will again comes back to API Gateway.
-> further API Gateway will go to that service, like Registration service ,payment service,login service,food order service etc.. so inside that service controllers are there which will take the request and process it.
-> after that the response comes into the api gateway and api gateway send it to front-end.
-> In api-gateway there are other things also present like, 
	i. SSO: which is working as an authentication service or security. 
	ii. Routing: It is routing the request to it's respective service.
	iii. Filter: it is used to check for the headers, cookies etc in the request.
-> we will register all services at EurekaServer. it works as microservices registry and discovery purpose.
-> All services common configurations are stored in a github/repo. from there config server picking configurations as per the services requirement.
-> For inter communication between microservices, acive MQ and kafka is working as messaging service. They follows asynchronous way of communication and Rest template follows synchronous way of communication.
-> Admin Server works as a actuator, which helps to check the health(RAM, CPU, service is up or down... etc... )of a microservice.
-> Zipkin or sleuth works as a distributed tracing service, which helps to trace the flow of a request, that means how the request is going from one service to another.

1. Eureka Server Internal flow:
===============================
-> every microservices needs to be registered at a single place, that is known as Eureka server.
-> it contains all the details about microservice. like, the port number, number of instances etc..
-> it helps API gateway to locate the microservice.

How to create a microservice for Eureka Server:
-------------------------------------------
Step 1:
-------
Right click->new->spring starter->give project name->next->select dependency as Eureka server->next->finish

<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
</dependency>

Step-2:
--------
In application properties give Eureka properties file and change the port number.

server.port=8761
spring.application.name:EUREKA-SERVER SERVICE

#Eureka
eureka.instance.prefer-ip-address=true
eureka.instance.hostname=localhost
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false

Step-3:
--------
In main class, give annotation @EnableEurekaServer

Step-4:
-------
now inside every other microservices, we have to add a dependency as Eureka Client.

<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>

Step-5:
--------
In application properties we have to add some configurations provided below,

#Eureka
eureka.instance.prefer-ip-address=true
eureka.instance.hostname=localhost
eureka.client.service-url.defaultZone=http://localhost:8761/eureka
eureka.client.register-with-eureka=true
eureka.client.fetch-registry=true
spring.cloud.compatibility-verifier.enabled=false
==========================================================================================================================
task:
=====
create an application whihc contains model classes as Product and Order.
Order has 1. orderId, 2. orderQuantity, 3. orderAddress(only provide city name as address)
Product has  1. productId, 2. productName, 3. productPrice, 4. productDescription

create 2 controllers like 1. getAllOrders(note: contains both order and product details), 2. getOrderById
one more controller getOrdersByAddress which will provide all the orders from same address

2. Internal flow of API GATEWAY/Explain about API gateway:
--------------------------------------------------------------
-> when a request comes from user to server, api gateway will 1st validate the request structure.
-> it checks for header, cookies, authorization etc.., if the request is structurally correct then
 further it will send to eureka server as api gateway does not contains the microservices details.
-> now eureka server will process the request came from api gateway and send the microservice's
 details to api gateway in response.
-> further api gateway will route the request to that perticular microservice.
-> api gateway also provides security by the help of SSO[Single Sign On].

How to create a microservice for API Gateway:
------------------------------------------------
Step-1: Add dependency "Gateway and Eureka Client" in pom.xml file..
Step-2:In application.properties file add eureka properties file and change the port number
       server.port=9595
       spring.application.name=GATEWAY-SERVICE

       eureka.client.service-url.defaultZone=http://localhost:8761/eureka
       eureka.client.register-with-eureka=true
       eureka.client.fetch-registry=true
       eureka.instance.prefer-ip-address=true
Step-3:

3. Internal flow of Config Server:
--------------------------------------
->Config Server Service contains "config server" dependency. Another Microservice contains "config client" dependency.
->A microservice sends request to config server then config server will send that request to github repo.
->github repo contains properties which are common to all Microservices, present in key value pair format in application.properties file.
->Then, Git hub will sends those properties as response to config server and config server will provide those to microservice.
->For example, we are having 5 microservices, and for each microservice having JPA and database connection properties. So, instead of writing it in every microservices,
we will write these common properties in a github repo and will make use of it whenever required.

How to create a microservice for Config Server:
-----------------------------------------------
Step-1:We have to add "config server" dependency in pom.xml file.
Step-2:We have to add common configuration properties in github repo in key value pair in application.properties file.

spring.application.name=ConfigServerExample1

server.port=8888

#github setup
spring.cloud.config.server.git.uri=https://github.com/Ronali22/config_server_repo.git
spring.cloud.config.server.git.username=Ronali22
spring.cloud.config.server.git.password=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
spring.cloud.config.server.git.default-label=main

step-3:In main class we have to add @EnableConfigServer annotation.


4. Internal flow of Actuator and Admin Server:
----------------------------------------------
-> When we add actuator dependency in microservice, we get multiple endpoints which contains details about that microservice.
-> But here, the problem was we have to check manually individual microservices for their details.
->To overcome this issue, admin server came into picture. Admin sever provides a dashboard on which all the details of every microservice we can able to see visually.
-> For example, we are having 2 microservices. one is admin server service and other is a registration service. here we will add two dependencies,
(i) Admin server (ii) Admin Client
->In Admin server service we will add spring-boot-admin-starter-server dependency i.e admin server dependency.
->In Registration service we will add spring-boot-admin-starter-client dependency i.e admin client dependency.

How to create a microservice for Actuator:
-----------------------------------------------
Step-1:add actuator and spring web dependencyin pom file.
Step-2:to expose all the endpoints we have add:
       management.endpoints.web.exposure.include=*
step-3:In controller class,we ahve to add @RestController annotation before the class name as admin server provides multiple endpoints to know the details ogf microservice.
step-4:we have to give @GetMapping annoation adn provide a url, as we are doing a GET type of operation here

How to create a microservice for Admin Server:
-----------------------------------------------
Step-1: Add admin server dependency in pom file
step-2:in application.properties file give port number an dapplication name
step-3:In main class add @EnableAdminServer annotation
5. Microservices Communication:
--------------------------------
RestTemplate:
--------------
-> for intercommunication of microservices we use rest template.
-> by using this synchronous way of communication can be done.
-> it follows producer and consumer concept, where consumer will send a request to producer and producer will send response.
-> steps to implement rest template;
Step:1
-> create producer applciation with all types of endpoints(POST,PUT,DELETE,PATCH,GET etc..)
Step:2
-> create a consumer application. At controller layer we will make use of RestTemplate to send request to producer app and consume the response coming from it.
Step:3
->for consuming different types of producer endpoints we are having differnet methods which we can use in consumer application to consume the responses,
	producer's post type endpoint we can use postForEntity method at consumer,
	producer's get type endpoint we can use getForEntity method at consumer,
	producer's put,delete,patch type endpoints we can use exchange method at consumer.

6.Zipkin/Sleuth:
-----------------
-> When a request going through various microservices, to know that flow, we need to track that request. For this, purpose we are using zipkin and sleuth can be used.
->Trace Id: to track the entire flow of a request through microservices, we need one unique id is known as Tracing Id.
->Span Id: to know about the individual microservices log information, there will be one id, known as span Id.
-> in each  microservice we need to add two dependencies. 1. sleuth 2. zipkin client
->Sleuth is a dependency which is associated with each microservice and it helps to generate trace information.
->Zipkin client takes trace info of individual service from sleuth, then it sends that information to Zipkin server.
->Zipkin server is a central server which collects all data coming from zipkin clients and show it on a dashboard.
-> zipkin server provides some features like we can filter traceid's, by their id's, by date, by time etc.etc.

7. Circuit Breaker:
=======================             
->The concept of a circuit breaker is to prevent calls to microservice when its known, that the call may get fail or timeout.
->Spring clouds resiliance4j is an api given for circuit breaker concept.It also called as Fault Tolerance API, it reduces error rate by stopping execution of failure services.
->3 types of circuit concept exist. 
1.Open circuit:In this state requests to other microservices will not be executed.Fallback method will be used to handle this type of scenarios.(Note: Fallback method: This returns a response message[error message] on behalf of failed microservice.)
2.Close circuit:Initially circuit breaker is in closed state.i.e. both microservices are connected and able to exchange request/response.
3.Half-Open circuit: initially circuits are in closed state. then when we start sending requests, if 50% of threshold limit get successfully sent to producer service then the circuit will remain in closed state else it will go to half open state.
further if the requests still fails then the circuits will go to open state.



Spring Security:
-----------------
-> from user, request comes to dispatcher servlet, then further it will sent to handler mapping,controller and view resolver.
-> so before request comes to dispatcher servlet, we can add security. for this a Filter can be added.
-> to implement security, we are having Filter(I). further java provides one implementation class of it, known as DelegatingFilterProxy. it contains one overloaded method "configure(...)".
-> one configure method used for authentication of user and other configure method used for authorization purpose.
-> Authentication: validating user credentials(username, password).
-> Authorization: validating user role or permission to access any page.
-> status codes to remember;
	-> when user credentials are incorrect we get 401 - unauthorized
	-> when user loggedin successfully with their credentials but not having the permission to access a specific page we get 403 - forbidden
	-> 200 - OK(success)
	-> 201 - Created
	-> 400 - bad request
	-> 404 - resource not found
	-> 500 - internal server error
------------------------------------------------------------------------------------------------------------------------------------------------------------
Interview Discussion:
---------------------
Marker interface: An interface without any abstract method, is known as marker interface. It doesn't contains any default method or any concrete method.
Idempotency: For any type of request, if we are getting similar response, is known as idempotent. Example: GetMapping, PUTMapping, DELETEMapping.

final:this keyword we can use it before a variable, method, class.
	if it placed before a variable then that variable's value can not be changed.
	if it placed before a method then that method can not be overridden.
	if it placed before a class name then it can not be extends or inherited.
finally:it used with try catch block to perfom some end tasks.
finalize:it uses for garbage collection.

use of pom file?
use of application properties file?
what is dependencies?
flow of mvc architecture?
can we addd sql queries directly into application?how?
microservice application vs monolithic applicaiton?
what is thread.sleep()?
why we use hbm-ddl-auto?
comparable vs comparator?
static vs nonstatic?
interface vs abstract classes?
waht is actuators?why to use?
why to use api gateway?
why java is platform independent?
why string is immutable in java?

Vehicle{
	
	int vehicleNo;

	Car{
		String carBrand;

	}

}

Vehicle.vehicleNo;
Car.carBrand;`
Vehicle.Car.carBrand;


1. Use of pom file
->POM->Project Object Model
->it contains artifact id(application name), group id(base package name),name,version,dependencies,plugins etc..
->Every java spring application has pom.xml file for maven applications, in case of gradle application its build.gradle file.

2.Using application.properties file
->It contains configuration properties for the application in key,value pairs
->For example we are adding JPA properties,database url and credentials and providing server port number.

3.Dependencies:
->Dependencies are nothing but a jar files only, which we require while building the application.

4.Flow of MVC Architecture:
->It is used to develop web applications.
-> Spring web follows front controller design pattern. in this only one servlet will handle all type requests, and that servlet is known as dispathcher servlet.
-> when a users comes to login page, they will provide their credentials(username & password).
-> then a request object will be created and send to server. in server dispatcher servlet is present to accept that request.
-> further dispatcher servlet will extract the URL present inside that request object and send it to "Handler Mapping".
-> Handler Mapping contains all controllers name which are mapped with respective type of requests. example: login.html -> login.java
-> then Handler Mapping will send the appropriate controller name to dispatcher servlet.
-> further dispatcher servlet will send that request to respective "Controller".
-> then controller will processs the request and in response provides model object and view name and sends it to dispatcher servlet.
Note: Model object used to transefer the java object to view(html/jsp page).
-> again dispatcher servlet will send the view name to "View Resolver". View Resolver checks that view is present or not. if present then it will send that view
	to dispatcher servlet or else 404 error page will send to dispatcher servlet.
-> futher dispatcher servlet will return the response to user.

5.can we addd sql queries directly into application?how?
->Yes,we can add sql queries directly into application by using @Query annotation and give the condition as nativeQuery = true and then give SQL query as value.

6.microservice application vs monolithic applicaiton?
->

7.what is Thread.sleep()?
->Thread.sleep() is used to pause the execution of the current thread for a specified time.

8.why we use hbm-ddl-auto?
->This the property we are using in application.properties file.
->This property is use for create and draw table automatically.

9.comparable vs comparator?
Comparable: 
->This method provides compareTo() method.
->It has one arguments.
->It's present in java.lang package.
->It's known as natural ordering.
Comparable:
->This method provides compare() method.
->It has two arguments.
->It's present in java.lang.util package.
->It's known as customize ordering.

10.static vs nonstatic?
Static:
->Defined within a class bu using static keyword.
->Static is also known as class variable.
->Memory allocated at the time of class is loaded.
->Can be referred using class name or object reference.(object reference is not preferred.)
Non-static:
->Defined within a class without using static keyword.
->Non-Static is also known as  instance variable.
->Memory allocated at the time of object is created.
->Can be referred using object reference only.

11.interface vs abstract classes?
Interface:
->Interface is a collection of public static final variables and public abstract methods.
->By using interface keyword, we can declare interface.
->Interface can have only abstract methods but from java 8, interface contatins concrete methods, known as default method.
-> Interface can contain static method as well.
Abstract class:
->Class declared with abstract keyword is known as abstarct class.
->By using abstarct keyword, we can declare abstarct class.
->Abstarct class can have abstarct and non-abstarct methods.

12.waht is actuators?why to use?
->When we add actuator dependency in microservice, we get multiple endpoints which contains details about that microservice.
->But here, the problem was we have to check manually individual microservices for their details.
->To overcome this issue, admin server came into picture. Admin sever provides a dashboard on which all the details of every microservice we can able to see visually.
-> For example, we are having 2 microservices. one is admin server service and other is a registration service. here we will add two dependencies,
(i) Admin server (ii) Admin Client

13.why to use api gateway?
->when a request comes from user to server, api gateway will 1st validate the request structure.
-> it checks for header, cookies, authorization etc.., if the request is structurally correct then
 further it will send to eureka server as api gateway does not contains the microservices details.
-> now eureka server will process the request came from api gateway and send the microservice's
 details to api gateway in response.
->further api gateway will route the request to that perticular microservice.
->api gateway also provides security by the help of SSO[Single Sign On].

16.why java is platform independent?
->When we write a java program, source code is compiled into bytecode as our system can understand and execute.
 Here,JVM acts as an interpreter for the bytecode. So, Java is a platform independent.
	.java ->  byte code -> binary code

15.why string is immutable in java?
->When we create a string using new keyword, it will create string object in HeapMemory as well as SCP(String Constant Pool).
->When we create a string using literal, it will create string object only in SCP.
->When we try to create another string using literal, it will check in SCP, whether it is already present or not.
  If it is present, then the variable will point towards existing object. So, if we try to change the value, then other variable also get affected as all are pointing towards same object.
->Similarly when we try to create string object using new keyword, it will create new object every time even if the string value is same.
thats why string is immmutable in java.

List<Employee> result=employeeList.stream().sort((e1,e2)->(e2.getEmployeeAge()-e1.getEmployeeAge()).collect(Collectors.toList());

Difference between ArrayList and LinkedList:
--------------------------------------------
ArrayList:
---------
->It is the Array representation.
->It uses an array to store elements.Which makes it fast to retrieve an element.
->But it's less efficient for inserting or deleting elements in the middle because elements needs to be shifted.

LinkedList:
-----------
->It is the List representation.
->here, each element is stored in a node, Which contains refrences to the next and previous nodes. This makes it efficient for inserting or deleting
  elemets at any position in the list.
->But it's not preferred when we need fast random access to an element.

Steps Of JDBC
--------------
Step 1: Load and register the driver
Step 2: Establish connection between Java program and database
step3:create platform to execute sql query
step4:execute sql query
step5:Fetch and print result
step6:close costly resources

Steps Of Hibernate
-------------------
Step1: Configuration[C]
	-> provides connection properties
	-> provides mapping information
	-> used to get reference of SessionFactory
Step2: SessionFactory[I]
	-> configures db
	-> manage connections
	-> provides reference of Session
Step3: Session[I]
	-> Session is a live connection between app and db
	-> it does crud operations
	-> gives reference of Transaction, Criteria, Query
Step4: Transaction[I]
	-> commits or roll back

`

@Data=> its a lombok annotation. it contains default constucor, setters and getters, tostring.
@NoArgsConstructor=> signifies default constructor
@AllArgsConstructor=> signifies parameterized constructor

Spring Boot Questions:
----------------------
1. What is Spring Boot? How it differ from Spring.
Ans: ->Spring Boot is a spring module, which is part of a spring framework.
     ->Benefits of Springboot over spring:
  i. We don't have to add dependencies manually from maven repository.
  ii. No version mismatching of dependencies.
  iii. It helps to develop application rapidly by using boilerplate code(boilerplate refers to coomon codes used for project building)
  iv. It provides starter dependencies.

2.What is the purpose of Spring Boot starters?
Ans:

3.Diff. b/w @Component, @Service and @Repository.
Ans: @Component: It is used to declare a class as an spring object. It's a class-level annotation
     @Service: It is used to declare a class as service. It is used in service layer. It tells spring that it contains business logic.
     @Repository: It is used to declare a class as Repository. It is basically used in repository layer.This layer directly deals with database.

4.How does spring boot manages dependency injection?
Ans: -> Dependency Injection follows Has-A relationship concept. That means one class has another class onject inside it.
     ->We can inject one class object into another class by using @Autowired annotation. We can do it by using xml configuration also.
     ->We are using @Bean annotation to create bean or objects. It is a method-level annotation. It is alternative of XML<bean> tag.

5.How does springboot support microservices?
Ans: ->

6.What is Spring Boot Actuator?
Ans:->Admin server works as a actuator, which is used to check the health of our application(like: Working condition of CPU, Service is up or down etc..)
    ->When we add actuator dependency, it gives us multiple endpoints, whcih contains details about that microservice.
    ->But here the problem is, we have to check manually individual microservices for their details.
    ->To overcome this problem, Admin server came into picture. It provides us a dashboard, which contails every details of microservice.
    ->For example, we are having 2 microservices. one is admin server service and other is a registration service. here we will add two dependencies,
      (i) Admin server (ii) Admin Client
   ->For Admin server service we will add admin server dependency.
   ->For Registration service we will add admin client dependency.

7.Diff. b/w CRUD Repository and JPA Repository.
Ans: CRUD Repository:
    ->CRUD Repository is a interface, available in spring boot applocations.
    ->It contains methods for doing CRUD operations.
    ->In CRUD repository we can do CREATE,READ,UPDATE,DELETE operations.
    JPA Repository:
    ->

8.How does Spring Boot handle database interactions?
Ans: ->

9.How does Spring security work?
Ans: -> from user, request comes to dispatcher servlet, then further it will sent to handler mapping,controller and view resolver.
     -> So, before request comes to dispatcher servlet, we can add security. for this a Filter can be added.
     -> to implement security, we are having Filter(I). further java provides one implementation class of it, known as DelegatingFilterProxy. 
        It contains one overloaded method "configure(...)".
     -> one configure method used for authentication of user and other configure method used for authorization purpose.
     -> Authentication: validating user credentials(username, password).
     -> Authorization: validating user role or permission to access any page.

10.What is caching in spring boot?
Ans:

11.How does spring boot handle exception handling?

Core Java interview Qus:
------------------------
1. What are JVM,JRE and JDK.
Ans: ->JDK:Java Development Kit.
     ->JDK is a complete software package which has every tools for development of a java program.
     ->JDK has JRE,JAR tools,compiler,Debugger etc..
     ->JRE:Java Runtime Environment
     ->JRE contains JVM & standard Runtime Libraries.
     ->JRE is a part of JDK, which provides a platform to execute java application.
     ->JVM: Java Virtual Machine
     ->JVM executes the byte code.
     ->JVM has the class loader,JIT compiler(Just In Time Complier),garbage collector
     ->It is a runtime instance which is created when we run the java class.

2.How does Java achieve platform independence.
Ans: ->When we create a java progarm, source code compiled into byte code by JVM and it generate a .class file.
     ->This .class file, we can run it in any operating system.Exa:Linux,IOS,WINDOWS
     ->This is why Java is known as platform independent.Java follows WORA(Write Once Read Anywhere).

3.How does java handle memory management?
Ans:

4.Diff. b/w == and .equals()
Ans:-> == is a comparision operator.(= is assignment operator)
    ->It uses to compare 2 objects address. If both are equal, then it will return true, else it will return false.
    ->.equals() compares two objects with respect to their content.

5.Diff b/w Synchronized and volatile?
Ans:

6.How does java handle thread communication?
Ans:

JVM Architecture:
-----------------
->JVM Architecture contains 5 components.
1.Class Loader:
----------------
-> it used to load class files.
-> it is responsible for 3 tasks. a. loading, b. linking, c. initialization
2. Memory Areas:
-----------------
-> it has 5 types of memory areas.
	a. method area
	b. heap area(scp present inside thihs known as meta space)
	c. stack area
	d. pc register
	e. native method area
3. Execution engine:
---------------------
-> it contains 3 components.
	a.interpreter
	b. JIT compiler
	c. garbage collector/security manager
4. java native interfaces
5. native method libraries

JUnit:
-------
->When developer writes a piece of code, that code has to be tested before sending it to QA.For this, developer takes help of JUnit.
->While testing a method we ahve to add 'test' as prefix or suuffix to the method name.
->There are different annotations we use for Junit testing, below:
@DisplayName:used to provide a display name for test method
@Test:used to mark a method as a test method
@Tag:used to provide a tag wrt environment
assertions:To test different conditions we require assertions.There are different assertion condition are there,i.e assertEquals,assertNull,assertNotEqual etc..
@BeforeAll:This code block should execute before all method
@BeforeEach:This code block should execute before each method.
@Disabled:It disables the method
@Order:It helps to execute the method in an defined order
@TestMethodOrder:Used to configure a method order for executing test methods.
@RepeatedTest:used to define how many times we want to execute a method
@AfterEach:This code block should execute after each method.
@AfterAll:This code block should execute after all method
->To make JUnit testing easier, we are having different frameworks as well.For example. Mockito, wire mock etc...
->Mockito framework is based upon mocking concept.Different annotations we use here, like:
@Mock:It is used to create mock/dummy object
@InjectMock:It helps to inject mock beans or mock objects into the provided class.
->To test controller layer, we have to mock service and repository whereas we have to use @InjectMock annotation for conroller.
->To test Service layer, we have tp mock repository layer and we ahve to use @InjectMock annotation for service.

JIRA
====
-> it helps implementing agile methodology in a project.
-> generally client provides requirements. then BA[bussiness anlyst] will create features out of these requirements.
-> further the feature will be divided into tasks.
-> TL[team lead] will further decides how many tasks can be delivered for that sprint.
-> A sprint usually takes 15days to complete.
-> further TL will assign tasks to developers and developers starts to work upon those userstories after understanding the requirements.
-> all these things are getting done using this JIRA tool.
-> it helps to manage all the development work flow and manange the team efforts.

GIT
===
-> it stands for version control system.
-> while working in a project multiple members can be working in a single repository. so GIT helps to manage different versions of code base.
-> it provides different commands to operate over repository.
	git init=> initializes git on a folder/location
	git add=> add files from untracked to staging area
	git commit -m "msg"=> commits our local changes in local repo
	git push=> sends all the local commits to remote repo, it will not send the changes which are not commited in local.
	git pull=> pulls all remote changes to local repo
	