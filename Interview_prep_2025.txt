interview prep:-
====================

1. Core Java(OOPS Concept, Multithreading, exception, java8 features, collection)
2. Hibernate
3. Spring(Spring web, ORM, JEE, SPRING Core, AOP, JDBC)
4. Spring boot
5. Microservices(Eureka Server, API Gateway, Config server, Admin server, Zipkin and sleuth, Communication)
6. SQL Queries
7. GIT
8. Spring Security

JAVA:-
============

JVM Architecture:
-----------------
->It stands for Java Virtual Machine.
->It's a run time engine, responsible to run java based applications.
->It has two main tasks.
  1.load .class file
  2.execute .class file
->JVM Architecture contains 5 components.
1.Class Loader:
----------------
-> it used to load class files.
-> it is responsible for 3 tasks. a. loading, b. linking, c. initialization
2. Memory Areas:
-----------------
-> it has 5 types of memory areas.
	a. method area
	b. heap area(scp present inside this known as meta space)
	c. stack area
	d. pc register
	e. native method area
3. Execution engine:
---------------------
-> it contains 3 components.
	a.interpreter
	b. JIT compiler
	c. garbage collector/security manager
4. java native interfaces
5. native method libraries

static vs nonstatic.
Static:
->Defined within a class by using static keyword.
->Static is also known as class variable.
->Memory allocated at the time of class is loaded.
->Can be referred using class name or object reference.(object reference is not preferred.)
->It is stored in method area.
Non-static:
->Defined within a class without using static keyword.
->Non-Static is also known as  instance variable.
->Memory allocated at the time of object is created.
->Can be referred using object reference only.
->it is stored in heap area.

What are JVM,JRE and JDK.
Ans: ->JDK:Java Development Kit.
     ->JDK is a complete software package which has every tools for development of a java program.
     ->JDK has JRE,JAR tools,compiler,Debugger etc..
     ->JRE:Java Runtime Environment
     ->JRE contains JVM & standard Runtime Libraries.
     ->JRE is a part of JDK, which provides a platform to execute java application.
     ->JVM: Java Virtual Machine
     ->JVM executes the byte code.
     ->JVM has the class loader,JIT compiler(Just In Time Complier),garbage collector
     ->It is a runtime instance which is created when we run the java class.

How does Java achieve platform independence?
Ans: ->When we create a java progarm, source code compiled into byte code by JVM and it generate a .class file.
     ->This .class file, we can run it in any operating system.Exa:Linux,IOS,WINDOWS
     ->This is why Java is known as platform independent.Java follows WORA(Write Once Read Anywhere).

String:
-------
-> in java String is a class.
-> we can create a String using different ways, 1. using new keyword, 2. by string literals
ex: String s1 = new String("car");//new keyword
    String s2 = "bike";//literals
Q. Why String is immutable in Java?
->When we create a string using new keyword, it will create string object in HeapMemory as well as SCP(String Constant Pool).
->When we create a string using literal, it will create string object only in SCP.
->When we try to create another string using literal, it will check in SCP, whether it is already present or not.
  If it is present, then the variable will point towards existing object. So, if we try to change the value, then other variable also get affected as all are pointing towards same object.
-> similarly when we try to create string object using new keyword, it will create new object every time even if the string value is same.
thats why string is immmutable in java.

OOPS[object oriented programming]
----------------------------------
Note: 
* variables=>properties, fields
* methods=>behaviours, functions
* in java every classes extends Object class by default.

1.Inheritance
--------------
->Acquiring properties from parent class to child class.
-> type
a. single inheritance-> one parent and one child class
b. multiple inheritance-> not supported (in terms of classes not supported, in terms interface supported)
c. multilevel inheritance-> one child, one parent, one grand parent class...... and so on
d. cyclic inheritance-> inter dependent classes
=> in terms of classes, java doesnot support multiple inheritance. it causes diamond problem thats why.
diamond problem: as object class is parent of every other class, when we create a child class named Vehicle, which extends two parent classes as Car, Bike.
                 Both parent classes are having a method as start(). in this scenario the java compiler will get confuse which start() method to be called.

2.Polymorphism
----------------
-> same name but different behaviour
example:- 
public int add(int a, int b){return a+b;}
public String add(String a, String b){return a+b;}
-> types
a. Compile time polymorphism-> method overloading( in same class, multiple methods with same name and different arguments)
b. Run time polymorphism-> Method overriding (in different class, multiple methods with same name and same arguments)

3.Abstraction
--------------
-> Hiding unwanted implementation and providing useful methods.
-> By using abstract classes and interfaces we can achieve abstraction.
-> If a class contains atleast one abstract method, then that class is known as abstract class.
->Abstract method- a method without implementation is known as abstract method. ex: public void engineStart();

4.Encapsulation
----------------
-> Binding properties and behaviours in a single unit.
-> To achieve encapsulation we have to declare all the properties/variables/fields as 'private' and to access those we have to provide public methods, known as setters and getters.

-----------------------------------------------------------------------------------------------------------------

Example of

1. Inheritance
----------------

class Vehicle{
 	String type;
 	int identficationNumber;
}

class Car extends Vehicle{
	String company;
}

class Tata{
}
public class InheritanceExample{
	public static void main(String[]args){
		Vehicle v=new Car();
		car c= (Car) v;
	sout.println(c.company);

}
}

2. Abstraction
----------------

package com.InterviewPractice;
abstract class Animal{

	String animalType;

	public void wildAnimal(){
	
	System.out.println("wild animal spotted");

	}

	public void domesticAnimal(){
	
	System.out.println("domestic animal spotted");

	}
	
	abstract public String animalStructure();

}

class Dog extends Animal{
	private int legs;

	public void wildAnimal(){
	
	System.out.println("wild animal spotted");
	}
	
	public String animalBehavior(){
		
		System.out.println("animals barking");
		return "animalBehavior";
	}
	@Override
	public String animalStructure() {
		System.out.println("abcd");
		return "animalStructure`";
	};

}
public class Abstracton {
	public static void main(String args[]){
	Animal a1=new Dog();
	a1.domesticAnimal();
	a1.wildAnimal();
	System.out.println("-----");

}
}

3. Encapsulation:
-----------------
package com.InterviewPractice;

class Bank{
	private String userName;
	private int userId;
	private String userAddress;
	
	public void setUserName(String name) {
		this.userName=name; //this keyword is used to refer same class non static variable.
	};
	public void setUserId(int id) {
		this.userId=id;
	}
	public void setUserAddress(String add) {
		this.userAddress=add;
	}

	public String getUserName() {
		return userName;
	}
	public int getUserId() {
		return userId;
	}
	public String getUserAddress() {
		return userAddress;
	}
	public String toString() {
		return userName+" "+userId+" "+userAddress;
	}
}
public class Encapsulation {
	public static void main(String[]args) {
		Bank bank=new Bank();
		bank.setUserName("Raju");
		bank.setUserId(2024);
		bank.setUserAddress("bbsr");
		System.out.print(bank);;
		
//		System.out.println(bank.getUserName());
//		System.out.println(bank.getUserId());
//		System.out.println(bank.getUserAddress());
	}
}

4.Polymorphism:
---------------
package com.InterviewPractice;

//note- resolving method call at compile time is known as compile time polymorphism.
// resolving method call at run time is known as run time polymorphism.
class Watch{
	void digital() {
		System.out.println("buying digital watch");
	}
	void digital(int a) {
		System.out.println("buying two "+a+" set digital watch");
	}
}
class DigitalWatch extends Watch{
	@Override
	void digital() {
		System.out.println("buying new digital watch");
	}
}
public class Polymorphism {

	public static void main(String[] args) {
		Watch w=new Watch();
		w.digital();
		w.digital(2);
		
		DigitalWatch d=new DigitalWatch();
		d.digital(); 

	}

}

Interface:
-----------
-> in interface all the variable are by default public static final and methods are public abstract.
-> Every interface itself an abstract.
-> Interfaces can't be instantiated.
-> Interface can be inherited into a class by using implements keyword.
-> Interface can also be inherited into another inteface by using extends keyword.
-> Whenever interface is inherited then all abstract methods of an interface must be overridden in a sub class or sub class must be declared with abstract keyword otherwise compile time error occurs.
-> an interface can contain concrete methods known as default methods.
-> as default methods introduced in java 1.7, to provide support to the older versions, we have to provide "default" keyword as prefix to the concrete methods,
   this is known as "backward compatibility".

example:
================
package com.InterviewPractice;

interface Bike {
	void speedUp();//abstract method

	default void electricSupport() {//concrete method
		System.out.println("Electric support provided");
	}
}

interface ElectricBike {
	void roboticBike();
}

class Remote implements Bike, ElectricBike {//multiple inheritance
	@Override
	public void speedUp() {
		System.out.println("speed increased");
	}

	@Override
	public void roboticBike() {
		System.out.println("Robotic bike has started");
	}
}

public class Interface {

	public static void main(String[] args) {
		Remote r = new Remote();
		r.speedUp();
		r.electricSupport();//calling default method
		r.roboticBike();
		
	}

}

Exception Handling:
-------------------
-> Unwanted termination/abroption of program during normal execution is known as exception.

Types:
------
1.Unchecked exception/Run-time exception
----------------------------------------
-> The exception which can't be checked by compiler at compile time.
-> ex: ArithmaticException, NullPointerException, IndexOutOfBoundException, ClassCastException

2.Checked exception/Compile-time exception
------------------------------------------
-> The exception which can be checked by compiler at compile time.
-> ex: ClassNotFoundException, IOException(FileNotFoundException, InterruptedIOException), SQLException

--> Exception can be handlled using 1. try........catch block 2. throw and throws 3.finally block

example:1
---------------
try...catch block
----------------------
class Math {
public static void main(String[] args) {
      int a = 100;
      int b = 0;
try{
      int c = a/b;
      System.out.println(c);
} catch (Exception e) {
      System.out.println(c);
}
}
}
example:2
---------------
package com.InterviewPractice.exception;

public class ExceptionHandlingExample {

	public static void main(String[] args) {
		int a = 100;
		int b = 0;
		int c = 0;
//		try {
//			c = a / b;// risky code
//		} catch (ArithmeticException e) {
//			System.out.println("inside ArithmeticException's catch block");
//		} catch (Exception e) {
//			System.out.println("inside Exception's catch block");
//			c = c + 15;
//		} finally {
//			System.out.println("thank you");
//		}
		try {
			c = a / b;// risky code
		} catch (ArithmeticException | NullPointerException e) {//multiple exceptions can be present inn a single catch byusing "or" operator.
			System.out.println("inside catch block");
		} finally {
			System.out.println("thank you");
		}
		System.out.println(c);
		System.out.println("working");
	}

}
note: multiple catch with a single try block can be written. but the exceptions should be handled from child to parent type.

throw..........throws keyword:
-------------------------------
-> throw is used to create new exception where as throws is used to declare an exception.

example:3
-----------------
package com.InterviewPractice.exception;

//checked exception example
class DemoException extends Exception {
	DemoException() {// constructor
		System.out.println("car exception occured");
	}

	DemoException(String msg) {
		System.out.println(msg);
	}
}

//unchecked exception example
class Demo2Exception extends RuntimeException {
	Demo2Exception() {// constructor
		System.out.println("car exception occured");
	}

	Demo2Exception(String msg) {
		System.out.println(msg);
	}
}

public class ThrowAndThrowsExample {
	public static int division(int a, int b) throws DemoException{
		return a / b;
	}

	public static void main(String[] args) {
		int a = 100;
		int b = 0;
		try {
			if (b == 0) {
				throw new Demo2Exception("exception occured");
			}
			int result = division(a, b);
			System.out.println(result);

		} catch (DemoException | Demo2Exception e) {
			System.out.println("inside catch block");
		}
		System.out.println("abc");
		System.out.println("abc");
		System.out.println("abc");
		System.out.println("abc");
	}
}
---------------------------------------------------------------
multithreading:
------------------
-> in programming we are having multi tasking. this can be of two types. 
1. multiprocess: multiple processes like playing video on vlc media, working on ide, listening music etc we can do simultaneously. this is know to be multiprocess
	process: process ia an independent task. its is having its own resources and memory. example:vlc media, working on ide, listening music etc
2. multithreading:Multithreading is a process of execution of more than one thread at a time or simulateneously.
->In multithreading threads are sharing a common resource or memory.
-> thread can be created in 2 ways.
1. by extending Thread class
2. by implementing Runnable interface

Thread: thread is an independent path of execution. thread is a light weight process. Thread class is present inside java.lang package.

-> A thread can not be started more than once. if we try to do so then it will throw IllegalThreadStateException.
Types of thread:
----------------
1. Deamon thread:
	-> these are low priority threads which performs low priority tasks like checking for updates, maintaining history/backups etc..
	-> JVM does not give much importance to these types of threads.
2. non deamon thread:
	-> these are high priority tasks used to carry the main tasks. JVM gives much importance to it.example: main thread in an java programm(refers to main method)
-> by default a thread is deamon or non deamon that is depends on parent thread. if parent thread is deamon then child thread will also be a deamon thread.
-> we can set a thread as deamon by using "setDeamon() as true".
-> we should set the thread as deamon or nondeamon before starting it.
Thread priority:
---------------
-> every thread has priority level. it veries from 1 to 10. 1 means low 10 means high.
-> based on the priority of a thread, thread scheduler schedules the thread execution.
-> by default a thread priority is same as the parent thread's priority.
-> main threads priority is 5.
-> we can set a threads priority by using setPriority() method.

example:1
-----------
package com.InterviewPractice.multithread;

//String userName;//varibale
//String userName();//abstract method
//String userName(){};//concrete method
//new UserName();//class obejct creation

class MyThread1 extends Thread{//creating thread using Thread class
	public void run() {
		for(int i = 1; i<=100;i++) {
			System.out.println(i);
		}
	}
}

class MyThread2 implements Runnable{//creating thread using Runnable interface

	@Override
	public void run() {
		for(int i = 1001; i<=1100;i++) {
			System.out.println(i);
		}
	}
	
}

public class MultithreadingExample {
	public static void main(String[] args) {
		MyThread1 t1 = new MyThread1();
		t1.start();
		
		MyThread2 t2 = new MyThread2();
		Thread myThread = new Thread(t2);
		myThread.start();
		
	}
}
------------------------------------------------------------
Collections Framework:
------------------------
1. List:
---------
(i) ArrayList:
--------------
-> It is a list implementation class.
-> it follows array representation.
->it allows duplicate elements as it implements list interface.

package com.InterviewPractice.collection;

import java.util.*;

public class ArrayListEx {

	public static void main(String[] args) {
		ArrayList <Integer> al=new ArrayList<>();
		al.add(15);
		al.add(65);
		al.add(58);
		al.add(76);
		System.out.println(al);
	}

}

(ii) LinkedList:
-----------------
-> It is a list implementation class.
-> it follows linked representation.
-> it allows duplicate elements as it implements list interface.
-> stores elements in insertion order.

package com.InterviewPractice.collection;

import java.util.*;

public class LinkedListEx {
	
	public static void main(String[] args) {
		LinkedList <Integer> ll=new LinkedList<>();
		ll.add(25);
		ll.add(64);
		ll.add(51);
		ll.add(88);
		System.out.println(ll);
	}

}

2. Set:
--------
(i) HashSet:
------------
-> it is an implementation of hashing technique with array representation.
-> it doesnot allow duplicate elements as it implements set interface.
-> it's an unordered set because here insertion order is not preserved.

Hashing:
---------
-> it is a technique which allows insertion, deletion and find operations in a constant average time.

package com.InterviewPractice.collection;

import java.util.*;

public class HashSetEx {

	public static void main(String[] args) {
		HashSet <Integer> hs=new HashSet<>();
		hs.add(50);
		hs.add(65);
		hs.add(47);
		hs.add(15);
		System.out.println(hs);

	}

}

(ii) LinkedHashSet:
---------------------
-> It is an implementation of hashing technique with linked representation.
-> Here, insertion, deletion order is preserved because it is an ordered set.
-> it doesnot allow duplicate elements because it implements set interface.

package com.InterviewPractice.collection;

import java.util.*;

public class LinkedHashSetEx {

	public static void main(String[] args) {
		LinkedHashSet <Integer> lhs=new LinkedHashSet<>();
		lhs.add(54);
		lhs.add(35);
		lhs.add(77);
		lhs.add(85);
		System.out.println(lhs);


	}

}

(iii) TreeSet:
---------------
-> It is an implementation of binary search tree technique with linked representation.
-> it doesn't allow duplicate values as it implemets list interface.
->all elements are sorted because it is a sorted set.

Binary search tree:
--------------------
->A binary tree said to be a binary search tree if it follows the following rules.
i. if the element is less than root element then it must be in left sub tree.
ii. if the element is greater than root element then it ust be in right sub tree.

package com.InterviewPractice.collection;

import java.util.*;

public class TreeSetEx {

	public static void main(String[] args) {
		TreeSet <Integer> ts=new TreeSet<>();
		ts.add(21);
		ts.add(89);
		ts.add(44);
		ts.add(82);
		System.out.println(ts);


	}

}

(3) Queue:
-----------
->it is an implementation of queue data structure.
->It follows FIFO principle
->it allows insertion in rear end only.
->it allows deletion in front end only.

(i) Priority Queue:
--------------------
-> in priority queue least element is the highest priority.
-> it allows duplicate elements.
->Here offer() method is used to insert the elements and poll() method is used to delete the elements.
->here, insertion order is not preserved.

package com.InterviewPractice.collection;

import java.util.*;

public class PriorityQueueEx {

	public static void main(String[] args) {
		PriorityQueue <Integer> pq=new PriorityQueue<>();
		pq.offer(56);
		pq.offer(65);
		pq.offer(98);
		pq.offer(10);
		pq.offer(25);
		
		System.out.println(pq);
		System.out.println(pq.poll());
		System.out.println(pq);
		System.out.println(pq.poll());
		System.out.println(pq);

	}

}

(ii) Array Deque:
------------------
-> It is an implementation of double ended queue data structure with array representation.
-> it allows duplicate elements.
->it allows both insertion and deletion at both the end, as it implemnts dequeue interface.

package com.InterviewPractice.collection;

import java.util.*;

public class ArrayDequeEx {

	public static void main(String[] args) {
		ArrayDeque <Integer> ad=new ArrayDeque<>();
		ad.add(20);
		ad.add(84);
		ad.add(49);
		ad.add(62);
		System.out.println(ad);
	}//

}


--------------------------------------------------------------------------------------------------------------------------------------------------------

Java 8 features:
----------------
1. new Date and Time api
2. Lambda expression
3. Functional interface
4. Stream API
5. Default methods in interface
6. Static methods in interface
7. Method reference
8. Constructor reference.
---------------------------------
1. Lambda expression:
--------------------
-> Lambda is an annonymous function.
-> it has no name, no accesss modifier, no return type.
->in java upto java 1.7, java was supporting only object oriented programming approach. then from java 1.8 onwards by the help of lambda expressions,
 functional interfaces, java supported "functional programming" approach.
->Functional Proframming- java 1.8 onwards, java supported functions as an argument to another function. This is known as functional programming.

example: 
public static void m1(){System.out.pritln("hello")}; => () -> System.out.println("hello");
public static int m2(int a, int b){return a+b}; => (a, b) -> a+b;
public static void m3(String name){System.out.pritln(name)}; => (name) -> System.out.println(name);

2. Functional interface:
-----------------------------
-> an interface which having only one abstract method is known as functional interface.
-> functional interface is used to invoke/call lambda expression.
-> Comprator is example of functional interface which gives us compare() method.

example:
package com.InterviewPractice.example;

//with lambda expression
@FunctionalInterface
interface Car{
	void startEngine();
}
public class LambdaExpressionExample {
	public static void main(String[] args) {
		Car c1 = ()->System.out.println("engine started");//here we are storing a function (i.e annonymous function/lambda expression) inside a variable.
		c1.startEngine();
		
	}

}
-----------------------------
-> java provided some predefined functional interfaces.
1. Predicate:test(T t)
2. Suplier:get()
3. Consumer:accept(T t)
4. Function: apply(T t)

example:
import java.util.function.Predicate;

//class PredicateDemo {
//	public boolean test(int i) {
//		if (i % 2 == 0))
//		else
//			return false;
//	}
//}

public class LambdaExpressionExample2 {
	
	public static void main(String[] args) {
//		PredicateDemo pd = new PredicateDemo();
//		boolean result = pd.test(5);
//		System.out.println(result);
		
		//by using lambda expression and functional interface
		 Predicate<Integer> p = i -> i % 2 == 0;
		 System.out.println(p.test(10));
	}
	
}
-------------------------
Method Reference:
-----------------
-> Instead of using lamda expression, we can also use method reference.

example:
package com.InterviewPractice.example;

import java.util.List;
import java.util.function.Predicate;

// WAP to print student names starting with A.
public class LambdaExpressionAndMethodReferenceExample3 {

	public static boolean checkName(String name) {
		if (name.charAt(0) == 'A')
			return true;
		else
			return false;
	}

	public static void main(String[] args) {
		List<String> sl = List.of("Akash", "Bikash", "Kailash", "Anil", "Amrut");
//		Predicate<String> p=name->name.charAt(0)== 'A';
		Predicate<String> p = LambdaExpressionAndMethodReferenceExample3::checkName;//on static context
		
//		LambdaExpressionExample3 le = new LambdaExpressionExample3();//on non-static context(remove static keyword from checkName)
//		Predicate<String> p = le::checkName;

		for (String studentName : sl) {
			if (p.test(studentName))
				System.out.println(studentName);
		}

	}

}
-------------------------
Stream API:
------------
-> from java 1.8 onwards stream api came into picture.
-> we use collection to store data and we use stream api to process the data.
-> stream api has two type of operation to perform. 
	1. intermediate funcitons: map(), filter(), flatmap() etc..
	2. terminal functions: max(), min(), count() etc..
-> stream is like a flow of data which can be preocessed once only.
-> stream does not change/modify the data present in the collection.
-> map(): if we want to perform any task on each and every elements present inside a collection then we can use map().
-> filter(): if we want to preform some filter operation on a collection of data then we can use filter().
-> a stream can be created in two ways. 
	1. Stream.of() 
	2. <collectionType>.stream(), example: list.stream()
example:
package com.InterviewPractice.revision;

import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

//1. WAP to filter female employee.
//2. WAP to increment salary by 20,000 for each employee
//3. WAP to filter employees whose salary is more than 20,000
//4. WAP to filter employees whose name starts with R
//5. WAP to filter employees whose salary is between 20000 to 40000
//6. WAP to count employees whose name starts with R
//7. WAP to find whose salary is maximum
//8. WAP to find whose salary is minimum
//9. WAP to sort the employees according to their salary in descending order

class Employee{
	private String employeeName;
	private String employeeGender;
	private double employeeSalary;
	
	public Employee(String employeeName, String employeeGender, double employeeSalary ){
		super();
		this.employeeName=employeeName;
		this.employeeGender=employeeGender;
		this.employeeSalary=employeeSalary;
	}
	public String getEmployeeName() {
		return employeeName;
	}
	public void setEmployeeName(String employeeName) {
		this.employeeName = employeeName;
	}
	public String getEmployeeGender() {
		return employeeGender;
	}
	public void setEmployeeGender(String employeeGender) {
		this.employeeGender = employeeGender;
	}
	public double getEmployeeSalary() {
		return employeeSalary;
	}
	public void setEmployeeSalary(double employeeSalary) {
		this.employeeSalary = employeeSalary;
	}
	@Override
	public String toString() {
		return "Employee [employeeName=" + employeeName + ", employeeGender=" + employeeGender + ", employeeSalary="
				+ employeeSalary + "]";
	}
	
}
public class Example1 {

	public static void main(String[] args) {
		
Employee employee1 = new Employee("Raju", "Male", 10000.00);
//System.out.println(employee1.getEmployeeGender());
Employee employee2 = new Employee("Sita", "Female", 20000.00);
Employee employee3 = new Employee("Hari", "Male", 30000.00);
Employee employee4 = new Employee("Gita", "Female", 60000.00);
Employee employee5 = new Employee("Mita", "Female", 50000.00);
Employee employee6 = new Employee("Rahul", "Male", 70000.00);

List<Employee> employeeList= List.of(employee1, employee2, employee3, employee4, employee5, employee6);

	//1.
	//List<Employee> result = employeeList.stream().filter(e->e.getEmployeeGender()=="Female").collect(Collectors.toList());
	//System.out.println(result);
	
	//2.
	//employeeList.stream().map(e->e.getEmployeeSalary()+20000.00).collect(Collectors.toList()).forEach(System.out::println);
	
	//3.
	//employeeList.stream().filter(e->e.getEmployeeSalary()>20000.00).collect(Collectors.toList()).forEach(System.out::println);
	
	//4.

//	employeeList.stream()
//			.filter(e->e.getEmployeeName().charAt(0)=='R')
//			.collect(Collectors.toList())
//			.forEach(System.out::println);;
	
	//5.
	
//	List<Employee> result = employeeList.stream()
//			.filter(e->(e.getEmployeeSalary()>20000.00 && e.getEmployeeSalary()<40000.00))
//			.collect(Collectors.toList());
	//System.out.println(result);
	
	//6.
//	long count  = employeeList.stream()
//			.filter(e->e.getEmployeeName().charAt(0)=='R')
//			.count();
	//System.out.println(count);
	
	//7. 
	//Employee employeeWithMaxSalary = employeeList.stream().max((a,b)->(int)(a.getEmployeeSalary()-b.getEmployeeSalary())).get();
	//System.out.println(employeeWithMaxSalary);
	
	//8. 
	//Employee employeeWithMinSalary = employeeList.stream().min((a,b)->(int)(a.getEmployeeSalary()-b.getEmployeeSalary())).get();
	//System.out.println(employeeWithMinSalary);
	
	//9.
	List<Employee> result = employeeList.stream()
			.sorted(Comparator.comparing(Employee::getEmployeeSalary).reversed())
			.collect(Collectors.toList());
	result.forEach(System.out::println);
	}
}
-------------------------------------------------------------
Optional class:
---------------
-> Optional classes used for handling null.
-> if a method returns null value, then might be possible the upcoming method may get
	fail and will throw nullpointer exception. so to prevent this we can use optional class.
example:
-------
package com.InterviewPractice.example;

import java.util.Optional;

class Employee {
	private String employeeName;
	private String employeeGender;
	private double employeeSalary;

	public Employee(String employeeName, String employeeGender, double employeeSalary) {
		super();
		this.employeeName = employeeName;
		this.employeeGender = employeeGender;
		this.employeeSalary = employeeSalary;
	}

	public static Optional<Employee> getEmployee(String employeeName, String employeeGender, double employeeSalary) {
		// assuming data base logic written below and its fetching data from db
		return Optional.of(new Employee(employeeName, employeeGender, employeeSalary));
	}

	@Override
	public String toString() {
		return "Employee [employeeName=" + employeeName + ", employeeGender=" + employeeGender + ", employeeSalary="
				+ employeeSalary + "]";
	}
}

public class OptionalClassExample {
	public static void main(String[] args) {

		Optional<Employee> optionalEmployee = Employee.getEmployee("ram", "male", 25000.00);
		if (optionalEmployee.isEmpty() || optionalEmployee.isPresent())
			System.out.println(optionalEmployee.get());// getting the actual employee object as final result by using get()
	}
}
------------------------------------------------------------
-> After completing core java, we have seen collection framework, going forward in advance java there are JDBC, hibernate,servlet,JSP.
->In JDBC we are establishing the connection between java and database and storing data. But there is a problem, data can be stored in the form of values.
-> Apart from this, few more problems are there with JDBC, which are known as ORM problems. Those are:
 1. Problem of Relations
 2. Problem of inheritance
 3. Problem of navigation
 4. problem of grain
 5. problem of identity
-> In ORM, one class will be mapped with one table. each column of table represents fields present inside class and each row represents ojbects. 
-> To overcome these problem JPA standards has been specified. Any solution providers has to follow these standards.
-> Different vendors provided their solution to overcome these ORM problems, like- Ibatis, topLink, hibernate
-> By using hibernate we can store objects into database.
->Servlets deals with web technology(old).
-> In JSP we can write java and html code in the same page.

SPRING FRAMEWORK:
--------------------
-> Framework provides us some predefined functionalities.
-> it's like a half developed project, which contains configurations, dependencies, methods, classes etc.. which helps us to develop our application faster. Ex: Spring framework, hibernate framework
-> Spring framework contains. 1. AOP 2.JDBC 3.ORM 4.JEE 5.MVC(WEB) 6.Spring core (IOC and DI) modules.
-> By using spring framework, majorly web based applications can be developed.

SPRING CORE:
------------
-> It has IOC and DI concept.
->IOC- Inversion of Control. DI- Dependency Injection.
->IOC: Inverting(providing) the power of object creation from developer to spring container.
->DI(Dependency Injection): It refers to HAS-A relationship. One class has another classes object inside it, that means, 
	we will inject one class object into another class by using '@Autowired' annotation.(We can do it using xml configuration as well).
Note- Inheritance follows IS-A relationship where one class extends another class.
-> DI further divided into 3types.
	1. setter injection
	2. constructor injection -> by using xml configuration  => <constructor-args></constructor-args>
	3. field/property injection -> by using xml configuration  => <property></<property>
->Spring Core has spring container. It manages bean(objects inside spring container) life cycle.
->Spring Framework provides 2 containers.
 1. BeanFactory(old)(I)
 2. ApplicationContext (new) (I)

BeanFactory
-----------
-> supports xml configuration only.
-> It has one implementation class XmlBeanFactory(C).
->It also known as legacy container.
-> it supports simple java applications only.


ApplicationContext
-------------------
-> It supports all type of configuration.
Note: Spring framework suppoerts 3 types of configurations. 1.Xml 2.Java 3.Annotation
->It has multiple implementation classes.
Ex: 1.ClassPathXmlApplicationContext(C)
    2.FileSystemXmlApplicationContext(C)
    3.AnnotationConfigApplicationContext(C)
	
Advantages or why we use Spring framework:
-------------------------------------------	
->Spring framework helps to develop applications in a faster way, known as Rapid application development.
->Less error rate.
->Reduces duplicate code by providing boiler plate code.
-> it supports simple java applications as well as web based applications.

SPRING WEB:
-----------
->It is used to develop web applications.
-> Spring web follows front controller design pattern. in this only one servlet will handle all type requests, and that servlet is known as dispathcher servlet.
-> when a users comes to login page, they will provide their credentials(username & password).
-> then a request object will be created and send to server. in server dispatcher servlet is present to accept that request.
-> further dispatcher servlet will extract the URL present inside that request object and send it to "Handler Mapping".
-> Handler Mapping contains all controllers name which are mapped with respective type of requests. example: login.html -> login.java
-> then Handler Mapping will send the appropriate controller name to dispatcher servlet.
-> further dispatcher servlet will send that request to respective "Controller".
-> then controller will processs the request and in response provides model object and view name and sends it to dispatcher servlet.
Note: Model object used to transefer the java object to view(html/jsp page).
-> again dispatcher servlet will send the view name to "View Resolver". View Resolver checks that view is present or not. if present then it will send that view
	to dispatcher servlet or else 404 error page will send to dispatcher servlet.
-> futher dispatcher servlet will return the response to user.
------------------------------------
Spring Boot:
------------
-> its based upon spring framework.
-> benifits of spring boot application over spring application,
	1. we dont have to add dependencies mannually from maven repository.
	2. no version mismatching of dependencies
	3. helps to develop application rapidly by providing boilerplate code(boilerplates refers to common codes used for project building)
	4. it provides starter dependencies(starter dependencies are multiple dependecies in a single bundle)
-> every java spring application has pom.xml file for maven applications, in case of gradle application its build.gradle file.
-> it contains all the dependencies which we require to develope the application.
-> there are different types of architectures we can follow to develope an enterprise level application. majorly layer based architecture we follow.
-> in "Layer Based Architecture" there can be many layers we can create as per our convenience but there are mainly 3 layers present in an application.
	1. Controller layer
	2. Service layer
	3. Repository layer

Annotations:
---------------------
@SpringBootApplication: its a combination of @ComponentScan, @Configuration, @EnableAutoConfiguration
@ComponentScan: its used to scan base packages for beans/objects
@EnableAutoConfiguration: its used to enable project configuration automatically by spring container
@Configuration: its used enable annotation based configuration, it declares that the class is containning some configurations. its a class level annotaion.
@Component: it used to declare a class as an spring object
@Bean: it used to create beans or objects.its a method level annotaion.
@Controller: it used to declare a class as controller. Basically it used for controller layer.
@Service: it used to declare a class as service. Basically it used for service layer. it contains business logic.
@Repository: it used to declare a class as repository. Basically it used for repository layer. this layer directly deals with database.
@Autowired: it used for dependency injection.
@Entity: it used to make a class in entity. It maps class,fields with database table column.
@Table: it used to create a table name
@Id: it used to declare a field as primary key.(note: works only with integer/int type of id)
@GeneratedValue: it used to generate id automatically.
@Column: it written above fields to provide the column name or modified column name. 
@RestController: ReST + Controller => ReST(Representational state transfer) its an architecture. it deals with json objects(json=> javascript object notation). 
		it is used to transfer data via network. previously we were using XML to transfer data.(XML=> extensibile markup language)
		in web applications we use it to declare that the class is a controller which handles all type of web requests POST, GET, PATCH, DELETE etc..
@RequestMapping:it used to map a url to controller.We can povide the base url using it.
@PostMapping: it used for POST type url/endpoint. Generally we use it for insert operation.
@GetMapping: it used for GET type url/endpoint.Generally we use it for read operation.
@PutMapping: it used for PUT type url/endpoint.Generally we use it for update operation.
@PatchMapping:it used for PATCH type url/endpoint.Generally we use it for partial update operation.
@DeleteMapping:it used for DELETE type url/endpoint.Generally we use it for delete operation.
@Getter:it is used to generate getter methods.
@Setter:it is used to generate setter methods.
@ToString:it is used to print object.
@RequestBody:it is used to convert Json type object into userdefined object
@PathVariable:It is used to extract values from url
@RequestParam:it used to extract key value pairs fom url.
@Value: it is used to take user input from application properties file dynamically.
@Query: it is used to enable native query/sql query into our spring application.
ResponseEntity: it used to convert the reponse object into json type object.

Note:
------
method signature:
=========================
<access modifier> <return type> <mehod name>(method input arguments...){
	//method body
}

example:-

	normal/general method						method using lambda expression
-----------------------------------------------			------------------------------------------------------
public void print(String name1, String name2){		=>	(name1, name2) -> System.out.println(name1,name2);
	System.out.println(name1,name2);
}

example:
list.stream().filter(e->e.getEmployeeSalary()>20000.00).collect(Collectors.toList());

Task:
=====
//WAP to print how many female employees are there in the organization.
//WAP to print the name of all departments in the org
//WAP what is the average age of male and female employees in the org
//WAP to find the details of highest paid employee
//WAP to filter who has the most working exp in the org
//WAP to count the number of employees in each department.
//WAP to separate the employees who are younger or equal to 25 years and who are older than 25 years
//WAP to  filter the name of employees who joined after 2015.

1. list.stream().filter(e->e.getEmployeeGender()=="female").count
	sout.println("Number of female empoyees are:");
2.list.stream().map(e->e.getEmployeeDepartmentName()).collect(Collectors.toList()).forEach(System.out::println);
3.Double avgOfMale = list.stream().filter(e->e.getEmployeeGender()=="Male").collect(collectors.averagingInt(e->e.getEmployeeAge()));
  Double avgOfFemale = list.stream().filter(e->e.getEmployeeGender()=="Female").collect(collectors.averagingInt(e->e.getEmployeeAge()));
4.Emp maxSalary = employeeList.stream().max((a,b)->(int)(a.getEmployeeSalary()-b.getEmployeeSalary())).get();
                  System.out.println(maxSalary);
5.Emp workingExp = employeeList.stream().max((a,b)->b.getEmployeeYearOfJoining()-a.getEmployeeYearOfJoining())).get();
		System.out.println(workingExp);
7.employeeList.stream().filter(e->e.getEmployeeAge()<=25).collect(Collectors.toList()).forEach(System.out::println);
  employeeList.stream().filter(e->e.getEmployeeAge()>25).collect(Collectors.toList()).forEach(System.out::println);
8.employeeList.stream().filter(e->e.getEmployeeYearOfJoining()>2015).collect(Collectors.toList()).forEach(e->System.out.println(e));
=========================================================================================
Microserivce:
=============
Q.Diff b/w microservice and monolithic application.
-> Microservice, in other word its known as distributed application.
-> that means while a monolithic application contains all types of services in a single application, a microservice will create individual service to handle individual tasks.
-> these services will be interconnected.
->for example:- Swiggy application contains different services like food ordering, tracking, payment, registration, security etc.
->In monolithic application it's difficult to manage the development process.A single  code change in a particular code block can led to entire application failure.
->Monolithic applications are tightly coupled.
->Scaling is difficult.low flexibility.
->In microservice application it's easy to manage compare to monolithic as different tasks are performed in different services.
->Microservice application are loosely coupled i.e one change in a service will not effect other services.
->It is highly flexible and scalable in nature.

Microservice Architecture:
--------------------------
-> From front-end(client) user will send a http request which will come in json form to backend. in backend, server is there to receive the request.
-> here API Gateway will be the 1st service which will take the request. it works as a entry point or gate keeper to our microservice application.
-> then the request will go to eureka server. at eureka server it will get the microservice details associated with that request. then it will again comes back to API Gateway.
-> further API Gateway will go to that service, like Registration service ,payment service,login service,food order service etc.. so inside that service controllers are there which will take the request and process it.
-> after that the response comes into the api gateway and api gateway send it to front-end.
-> In api-gateway there are other things also present like, 
	i. SSO: which is working as an authentication service or security. 
	ii. Routing: It is routing the request to it's respective service.
	iii. Filter: it is used to check for the headers, cookies etc in the request.
-> we will register all services at EurekaServer. it works as microservices registry and discovery purpose.
-> All services common configurations are stored in a github/repo. from there config server picking configurations as per the services requirement.
-> For inter communication between microservices, acive MQ and kafka is working as messaging service. They follows asynchronous way of communication and Rest template follows synchronous way of communication.
-> Admin Server works as a actuator, which helps to check the health(RAM, CPU, service is up or down... etc... )of a microservice.
-> Zipkin or sleuth works as a distributed tracing service, which helps to trace the flow of a request, that means how the request is going from one service to another.

1. Eureka Server Internal flow:
===============================
-> every microservices needs to be registered at a single place, that is known as Eureka server.
-> it contains all the details about microservice. like, the port number, number of instances etc..
-> it helps API gateway to locate the microservice.

How to create a microservice for Eureka Server:
-------------------------------------------
Step 1:
-------
Right click->new->spring starter->give project name->next->select dependency as Eureka server->next->finish

<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
</dependency>

Step-2:
--------
In application properties give Eureka properties file and change the port number.

server.port=8761
spring.application.name:EUREKA-SERVER SERVICE

#Eureka
eureka.instance.prefer-ip-address=true
eureka.instance.hostname=localhost
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false

Step-3:
--------
In main class, give annotation @EnableEurekaServer

Step-4:
-------
now inside every other microservices, we have to add a dependency as Eureka Client.

<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>

Step-5:
--------
In application properties we have to add some configurations provided below,

#Eureka
eureka.instance.prefer-ip-address=true
eureka.instance.hostname=localhost
eureka.client.service-url.defaultZone=http://localhost:8761/eureka
eureka.client.register-with-eureka=true
eureka.client.fetch-registry=true
spring.cloud.compatibility-verifier.enabled=false
==========================================================================================================================
task:
=====
create an application whihc contains model classes as Product and Order.
Order has 1. orderId, 2. orderQuantity, 3. orderAddress(only provide city name as address)
Product has  1. productId, 2. productName, 3. productPrice, 4. productDescription

create 2 controllers like 1. getAllOrders(note: contains both order and product details), 2. getOrderById
one more controller getOrdersByAddress which will provide all the orders from same address

2. Internal flow of API GATEWAY/Explain about API gateway:
--------------------------------------------------------------
-> when a request comes from user to server, api gateway will 1st validate the request structure.
-> it checks for header, cookies, authorization etc.., if the request is structurally correct then
 further it will send to eureka server as api gateway does not contains the microservices details.
-> now eureka server will process the request came from api gateway and send the microservice's
 details to api gateway in response.
-> further api gateway will route the request to that perticular microservice.
-> api gateway also provides security by the help of SSO[Single Sign On].

How to create a microservice for API Gateway:
------------------------------------------------
Step-1: Add dependency "Gateway(Spring cloud Strater Gateway) and Eureka Client" in pom.xml file..
Step-2:In application.properties file add eureka properties file and change the port number
       server.port=9595
       spring.application.name=GATEWAY-SERVICE

       eureka.client.service-url.defaultZone=http://localhost:8761/eureka
       eureka.client.register-with-eureka=true
       eureka.client.fetch-registry=true
       eureka.instance.prefer-ip-address=true
Step-3:In main class create a confing class

3. Internal flow of Config Server:
--------------------------------------
->Config Server Service contains "config server" dependency. Another Microservice contains "config client" dependency.
->A microservice sends request to config server then config server will send that request to github repo.
->github repo contains properties which are common to all Microservices, present in key value pair format in application.properties file.
->Then, Git hub will sends those properties as response to config server and config server will provide those to microservice.
->For example, we are having 5 microservices, and for each microservice having JPA and database connection properties. So, instead of writing it in every microservices,
we will write these common properties in a github repo and will make use of it whenever required.

How to create a microservice for Config Server:
-----------------------------------------------
Step-1:We have to add "config server" dependency in pom.xml file.
Step-2:We have to add common configuration properties in github repo in key value pair in application.properties file.

spring.application.name=ConfigServerExample1

server.port=8888

#github setup
spring.cloud.config.server.git.uri=https://github.com/Ronali22/config_server_repo.git
spring.cloud.config.server.git.username=Ronali22
spring.cloud.config.server.git.password=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
spring.cloud.config.server.git.default-label=main

step-3:In main class we have to add @EnableConfigServer annotation.


4. Internal flow of Actuator and Admin Server:
----------------------------------------------
-> spring boot actuator is a feature which provides monitoring and management capabilitites for the spring application.
-> When we add actuator dependency in microservice, we get multiple endpoints which contains details about that microservice.like health status, metrices and environment variables etc.
-> But here, the problem was we have to check manually individual microservices for their details.
->To overcome this issue, admin server came into picture. Admin sever provides a dashboard on which all the details of every microservice we can able to see visually.
-> For example, we are having 2 microservices. one is admin server service and other is a registration service. here we will add two dependencies,
(i) Admin server (ii) Admin Client
->In Admin server service we will add spring-boot-admin-starter-server dependency i.e admin server dependency.
->In Registration service we will add spring-boot-admin-starter-client dependency i.e admin client dependency.

How to create a microservice for Actuator:
-----------------------------------------------
Step-1:add actuator and spring web dependencyin pom file.
Step-2:to expose all the endpoints we have add:
       management.endpoints.web.exposure.include=*
step-3:In controller class,we ahve to add @RestController annotation before the class name as admin server provides multiple endpoints to know the details ogf microservice.
step-4:we have to give @GetMapping annoation adn provide a url, as we are doing a GET type of operation here

How to create a microservice for Admin Server:
-----------------------------------------------
Step-1: Add admin server dependency in pom file
step-2:in application.properties file give port number an dapplication name
step-3:In main class add @EnableAdminServer annotation
5. Microservices Communication:
--------------------------------
RestTemplate:
--------------
-> for intercommunication of microservices we use rest template.
-> by using this synchronous way of communication can be done.
-> it follows producer and consumer concept, where consumer will send a request to producer and producer will send response.
->RestTemplate is a class in Spring Framework used to make HTTP requests to RESTful web services.
-> steps to implement rest template;
Step:1
->Add dependecies- lombok,spring-boot-starter, spring-boot-starter-web in pom file

Step-2:
->Create a entity class and inside this create  a class give some properties and add @Data- It is lombk annotation.It's equivalent to @Getter,@Setter and @ToString.  @NoArgsConstructor- defaukt constructor, @AllArgsConstructor-parameterized constructor

Step-3:
-> create producer controllerclass with all types of endpoints(POST,PUT,DELETE,PATCH,GET etc..)


Step:2
-> create a consumer application. At controller layer we will make use of RestTemplate to send request to producer app and consume the response coming from it.
Step:3
->for consuming different types of producer endpoints we are having differnet methods which we can use in consumer application to consume the responses,
	producer's post type endpoint we can use postForEntity method at consumer,
	producer's get type endpoint we can use getForEntity method at consumer,
	producer's put,delete,patch type endpoints we can use exchange method at consumer.

6.Zipkin/Sleuth:
-----------------
-> When a request going through various microservices, to know that flow, we need to track that request. For this, purpose we are using zipkin and sleuth can be used.
->Trace Id: to track the entire flow of a request through microservices, we need one unique id is known as Tracing Id.
->Span Id: to know about the individual microservices log information, there will be one id, known as span Id.
-> in each  microservice we need to add two dependencies. 1. sleuth 2. zipkin client
->Sleuth is a dependency which is associated with each microservice and it helps to generate trace information.
->Zipkin client takes trace info of individual service from sleuth, then it sends that information to Zipkin server.
->Zipkin server is a central server which collects all data coming from zipkin clients and show it on a dashboard.
-> zipkin server provides some features like we can filter traceid's, by their id's, by date, by time etc.etc.

7. Circuit Breaker:
=======================             
->The concept of a circuit breaker is to prevent calls to microservice when its known, that the call may get fail or timeout.
->Spring clouds resiliance4j is an api given for circuit breaker concept.It also called as Fault Tolerance API, it reduces error rate by stopping execution of failure services.
->3 types of circuit concept exist. 
1.Open circuit:In this state requests to other microservices will not be executed.Fallback method will be used to handle this type of scenarios.(Note: Fallback method: This returns a response message[error message] on behalf of failed microservice.) 
2.Close circuit:Initially circuit breaker is in closed state.i.e. both microservices are connected and able to exchange request/response.
3.Half-Open circuit: initially circuits are in closed state. then when we start sending requests, if 50% of threshold limit get successfully sent to producer service then the circuit will remain in closed state else it will go to half open state.
further if the requests still fails then the circuits will go to open state.
How to implement:
->We will create a fallback method to handle a scenario when the producer service is down and not able to respond.
step-2:
->We will add one annotation as @CircuitBreaker above the existing controller(PUT,PATCH,GET) and will provide the fallback method name as an input to it.

Spring Security:
-----------------
-> from user, request comes to dispatcher servlet, then further it will sent to handler mapping,controller and view resolver.
-> so before request comes to dispatcher servlet, we can add security. for this a Filter can be added.
-> to implement security, we are having Filter(I). further java provides one implementation class of it, known as DelegatingFilterProxy. it contains one overloaded method "configure(...)".
-> one configure method used for authentication of user and other configure method used for authorization purpose.
-> Authentication: validating user credentials(username, password).
-> Authorization: validating user role or permission to access any page.
-> status codes to remember;
	-> when user credentials are incorrect we get 401 - unauthorized
	-> when user loggedin successfully with their credentials but not having the permission to access a specific page we get 403 - forbidden
	-> 200 - OK(success)
	-> 201 - Created
	-> 400 - bad request
	-> 404 - resource not found
	-> 500 - internal server error
------------------------------------------------------------------------------------------------------------------------------------------------------------
Interview Discussion:
---------------------
Marker interface: An interface without any abstract method, is known as marker interface. It doesn't contains any default method or any concrete method.
Idempotency: For any type of request, if we are getting similar response, is known as idempotent. Example: GetMapping, PUTMapping, DELETEMapping.

final:this keyword we can use it before a variable, method, class.
	if it placed before a variable then that variable's value can not be changed.
	if it placed before a method then that method can not be overridden.
	if it placed before a class name then it can not be extends or inherited.
finally:it used with try catch block to perfom some end tasks those are low priority.Ex:Garbage collection, closing of costly resources
finalize:it is use to perfom clean-up processing before garbage collection.

use of pom file?
use of application properties file?
what is dependencies?
flow of mvc architecture?
can we addd sql queries directly into application?how?
microservice application vs monolithic applicaiton?
what is thread.sleep()?
why we use hbm-ddl-auto?
comparable vs comparator?
static vs nonstatic?
interface vs abstract classes?
waht is actuators?why to use?
why to use api gateway?
why java is platform independent?
why string is immutable in java?

Vehicle{
	
	int vehicleNo;

	Car{
		String carBrand;

	}

}

Vehicle.vehicleNo;
Car.carBrand;`
Vehicle.Car.carBrand;


1. Use of pom file
->POM->Project Object Model
->it contains artifact id(application name), group id(base package name),name,version,dependencies,plugins etc..
->Every java spring application has pom.xml file for maven applications, in case of gradle application its build.gradle file.

2.Using application.properties file
->It contains configuration properties for the application in key,value pairs
->For example we are adding JPA properties,database url and credentials and providing server port number.

3.Dependencies:
->Dependencies are nothing but a jar files only, which we require while building the application.

4.Flow of MVC Architecture:
->It is used to develop web applications.
-> Spring web follows front controller design pattern. in this only one servlet will handle all type requests, and that servlet is known as dispathcher servlet.
-> when a users comes to login page, they will provide their credentials(username & password).
-> then a request object will be created and send to server. in server dispatcher servlet is present to accept that request.
-> further dispatcher servlet will extract the URL present inside that request object and send it to "Handler Mapping".
-> Handler Mapping contains all controllers name which are mapped with respective type of requests. example: login.html -> login.java
-> then Handler Mapping will send the appropriate controller name to dispatcher servlet.
-> further dispatcher servlet will send that request to respective "Controller".
-> then controller will processs the request and in response provides model object and view name and sends it to dispatcher servlet.
Note: Model object used to transefer the java object to view(html/jsp page).
-> again dispatcher servlet will send the view name to "View Resolver". View Resolver checks that view is present or not. if present then it will send that view
	to dispatcher servlet or else 404 error page will send to dispatcher servlet.
-> futher dispatcher servlet will return the response to user.

5.can we add sql queries directly into application?how?
->Yes,we can add sql queries directly into application by using @Query annotation and give the condition as nativeQuery = true and then give SQL query as value.

6.microservice application vs monolithic applicaiton?
->Microservice, in other word its known as distributed application.
->while a monolithic application contains all types of services in a single applcation, a microservice will create indivisual service to handle individual tasks.

7.what is Thread.sleep()?
->Thread.sleep() is used to pause the execution of the current thread for a specified time.

8.why we use hbm-ddl-auto?
->This is the property we are using in application.properties file.
->This property is use for create and draw table automatically.

9.comparable vs comparator?
Comparable: 
->This method provides compareTo() method.
->It has one arguments.
->It's present in java.lang package.
->It's known as natural ordering.
Comparable:
->This method provides compare() method.
->It has two arguments.
->It's present in java.lang.util package.
->It's known as customize ordering.

10.static vs nonstatic?
Static:
->Defined within a class by using static keyword.
->Static is also known as class variable.
->Memory allocated at the time of class is loaded.
->Can be referred using class name or object reference.(object reference is not preferred.)
Non-static:
->Defined within a class without using static keyword.
->Non-Static is also known as  instance variable.
->Memory allocated at the time of object is created.
->Can be referred using object reference only.

11.interface vs abstract classes?
Interface:
->Interface is a collection of public static final variables and public abstract methods.
->By using interface keyword, we can declare interface.
->Interface can have only abstract methods but from java 8, interface contatins concrete methods, known as default method.
-> Interface can contain static method as well.
Abstract class:
->Class declared with abstract keyword is known as abstarct class.
->By using abstarct keyword, we can declare abstarct class.
->Abstarct class can have abstarct and non-abstarct methods.

12.waht is actuators?why to use?
->When we add actuator dependency in microservice, we get multiple endpoints which contains details about that microservice.
->But here, the problem was we have to check manually individual microservices for their details.
->To overcome this issue, admin server came into picture. Admin sever provides a dashboard on which all the details of every microservice we can able to see visually.
-> For example, we are having 2 microservices. one is admin server service and other is a registration service. here we will add two dependencies,
(i) Admin server (ii) Admin Client

13.why to use api gateway?
->when a request comes from user to server, api gateway will 1st validate the request structure.
-> it checks for header, cookies, authorization etc.., if the request is structurally correct then
 further it will send to eureka server as api gateway does not contains the microservices details.
-> now eureka server will process the request came from api gateway and send the microservice's
 details to api gateway in response.
->further api gateway will route the request to that perticular microservice.
->api gateway also provides security by the help of SSO[Single Sign On].

16.why java is platform independent?
->When we write a java program, source code is compiled into bytecode as our system can understand and execute.
 Here,JVM acts as an interpreter for the bytecode. So, Java is a platform independent.
	.java ->  byte code -> binary code

15.why string is immutable in java?
->When we create a string using new keyword, it will create string object in HeapMemory as well as SCP(String Constant Pool).
->When we create a string using literal, it will create string object only in SCP.
->When we try to create another string using literal, it will check in SCP, whether it is already present or not.
  If it is present, then the variable will point towards existing object. So, if we try to change the value, then other variable also get affected as all are pointing towards same object.
->Similarly when we try to create string object using new keyword, it will create new object every time even if the string value is same.
thats why string is immmutable in java.

List<Employee> result=employeeList.stream().sort((e1,e2)->(e2.getEmployeeAge()-e1.getEmployeeAge()).collect(Collectors.toList());

Difference between ArrayList and LinkedList:
--------------------------------------------
ArrayList:
---------
->It is the Array representation.
->It uses an array to store elements.Which makes it fast to retrieve an element.
->But it's less efficient for inserting or deleting elements in the middle because elements needs to be shifted.

LinkedList:
-----------
->It is the List representation.
->here, each element is stored in a node, Which contains refrences to the next and previous nodes. This makes it efficient for inserting or deleting elements at any position in the list.
->But it's not preferred when we need fast random access to an element.

Steps Of JDBC
--------------
Step 1: Load and register the driver
Step 2: Establish connection between Java program and database
step3:create platform to execute sql query
step4:execute sql query
step5:Fetch and print result
step6:close costly resources

Steps Of Hibernate
-------------------
Step1: Configuration[C]
	-> provides connection properties
	-> provides mapping information
	-> used to get reference of SessionFactory
Step2: SessionFactory[I]
	-> configures db
	-> manage connections
	-> provides reference of Session
Step3: Session[I]
	-> Session is a live connection between app and db
	-> it does crud operations
	-> gives reference of Transaction, Criteria, Query
Step4: Transaction[I]
	-> commits or roll back
`

@Data=> its a lombok annotation. it contains default constructor, setters and getters, tostring.
@NoArgsConstructor=> signifies default constructor
@AllArgsConstructor=> signifies parameterized constructor

Spring Boot Questions:
----------------------
1. What is Spring Boot? How it differ from Spring.
Ans: ->Spring Boot is a spring module, which is part of a spring framework.
     ->Benefits of Springboot over spring:
  i. We don't have to add dependencies manually from maven repository.
  ii. No version mismatching of dependencies.
  iii. It helps to develop application rapidly by using boilerplate code(boilerplate refers to coomon codes used for project building)
  iv. It provides starter dependencies(starter dependencies are multiple dependecies in a single bundle).

2.What is the purpose of Spring Boot starters?
Ans:Spring boot promotes rapid application development(RAD).So, it provides starter dependencies, which helps to build application faster.Starter dependecies are nothing but a bundle of related dependencies in a single package.

3.Diff. b/w @Component, @Service and @Repository.
Ans: @Component: It is used to declare a class as an spring object. It's a class-level  annotation
     @Service: It is used to declare a class as service. It is used in service layer. It tells spring that it contains business logic.
     @Repository: It is used to declare a class as Repository. It is basically used in repository layer.This layer directly deals with database.

4.How does spring boot manages dependency injection?
Ans: -> Dependency Injection follows Has-A relationship concept. That means one class has another class onject inside it.
     ->We can inject one class object into another class by using @Autowired annotation. We can do it by using xml configuration also.
     ->We are using @Bean annotation to create bean or objects. It is a method-level annotation. It is alternative of XML<bean> tag.

6.What is Spring Boot Actuator?
Ans:->Admin server works as a actuator, which is used to check the health of our application(like: Working condition of CPU, Service is up or down etc..)
    ->When we add actuator dependency, it gives us multiple endpoints, whcih contains details about that microservice.
    ->But here the problem is, we have to check manually individual microservices for their details.
    ->To overcome this problem, Admin server came into picture. It provides us a dashboard, which contails every details of microservice.
    ->For example, we are having 2 microservices. one is admin server service and other is a registration service. here we will add two dependencies,
      (i) Admin server (ii) Admin Client
   ->For Admin server service we will add admin server dependency.
   ->For Registration service we will add admin client dependency.

7.Diff. b/w CRUD Repository and JPA Repository.
Ans: Repository[I]
		|
	CrudRepository[I]
		|
	PagingAndSortingRepository[I]
		|
	JpaRepository[I]
->For our basic CRUD operations, all necessary methods available in CrudRepository.
->Apart from this for pagination functionality we are having PagingAndSortingRepository.
  Pagination->we can set how many data to be displayed for single page.
->Some extra functionalities for CRUD are available in JpaRepository.Like: Batch operations.

8.How does Spring Boot handle database interactions?
Ans: -> Spring data jpa module handles all database operations in spring.

9.How does Spring security work?
Ans: -> from user, request comes to dispatcher servlet, then further it will sent to handler mapping,controller and view resolver.
     -> So, before request comes to dispatcher servlet, we can add security. for this a Filter can be added.
     -> to implement security, we are having Filter(I). further java provides one implementation class of it, known as DelegatingFilterProxy. 
        It contains one overloaded method "configure(...)".
     -> one configure method used for authentication of user and other configure method used for authorization purpose.
     -> Authentication: validating user credentials(username, password).
     -> Authorization: validating user role or permission to access any page.

10.What is caching in spring boot?
Ans:->It helps to reduce database calls by introducing an extra layer before DB.
->It stores the result in temporary memory and whenever we hit an endpoint we will get response from this temporary memory instead of everytime directly hitting to DB.

Core Java interview Qus:
------------------------
1. What are JVM,JRE and JDK.
Ans: ->JDK:Java Development Kit.
     ->JDK is a complete software package which has every tools for development of a java program.
     ->JDK has JRE,JAR tools,compiler,Debugger etc..
     ->JRE:Java Runtime Environment
     ->JRE contains JVM & standard Runtime Libraries.
     ->JRE is a part of JDK, which provides a platform to execute java application.
     ->JVM: Java Virtual Machine
     ->JVM executes the byte code.
     ->JVM has the class loader,JIT compiler(Just In Time Complier),garbage collector
     ->It is a runtime instance which is created when we run the java class.

2.How does Java achieve platform independence.
Ans: ->When we create a java progarm, source code compiled into byte code by JVM and it generate a .class file.
     ->This .class file, we can run it in any operating system.Exa:Linux,IOS,WINDOWS
     ->This is why Java is known as platform independent.Java follows WORA(Write Once Read Anywhere).

3.How does java handle memory management?
Ans:We are having different types of memory provided by java in JVM to store it.
(Refer JVM architecture)

4.Diff. b/w == and .equals()
Ans:-> == is a comparision operator.(= is assignment operator)
    ->It uses to compare 2 objects address. If both are equal, then it will return true, else it will return false.
    ->.equals() compares two objects with respect to their content.

5.Diff b/w synchronized and volatile?
Ans:synchronized:
->only one thread can execute a synchronized block/method at a time.changes made by one thread are visible to others after the lock is released.
Ex:public synchronized void increment() {
    count++;
}

Volatile:
->Guarantees visibility only: when one thread updates a volatile variable, the new value is immediately visible to other threads.
Ex:private volatile boolean flag;

6.How does java handle thread communication?
Ans:By using two methods. i.async() ii.await()

JVM Architecture:
-----------------
->JVM is stands for Java Virtual Machine.
->It is a run time engine which is responsible for run java based application.
->It has 2 main tasks:
1.Load .class file
2.Execute .class file
->JVM Architecture contains 5 components.
1.Class Loader:
----------------
-> it used to load class files.
-> it is responsible for 3 tasks. a. loading, b. linking, c. initialization
2. Memory Areas:
-----------------
-> it has 5 types of memory areas.
	a. method area
	b. heap area(scp present inside thihs known as meta space)
	c. stack area
	d. pc register
	e. native method area
3. Execution engine:
---------------------
-> it contains 3 components.
	a. interpreter
	b. JIT compiler
	c. garbage collector/security manager
4. java native interfaces
5. native method libraries

JUnit:
-------
->When developer writes a piece of code, that code has to be tested before sending it to QA.For this, developer takes help of JUnit.
->While testing a method we ahve to add 'test' as prefix or suuffix to the method name.
->There are different annotations we use for Junit testing, below:
@DisplayName:used to provide a display name for test method
@Test:used to mark a method as a test method
@Tag:used to provide a tag wrt environment
assertions:To test different conditions we require assertions.There are different assertion condition are there,i.e assertEquals,assertNull,assertNotEqual etc..
@BeforeAll:This code block should execute before all method
@BeforeEach:This code block should execute before each method.
@Disabled:It disables the method
@Order:It helps to execute the method in an defined order
@TestMethodOrder:Used to configure a method order for executing test methods.
@RepeatedTest:used to define how many times we want to execute a method
@AfterEach:This code block should execute after each method.
@AfterAll:This code block should execute after all method

Mockito:
---------
->To make JUnit testing easier, we are having different frameworks as well.For example. Mockito, wire mock etc...
->Mockito framework is based upon mocking concept.Different annotations we use here, like:
@Mock:It is used to create mock/dummy object
@InjectMock:It helps to inject mock beans or mock objects into the provided class.
->To test controller layer, we have to mock service and repository whereas we have to use @InjectMock annotation for conroller.
->To test Service layer, we have to mock repository layer and we ahve to use @InjectMock annotation for service.

JIRA
====
-> it helps implementing agile methodology in a project.
-> generally client provides requirements. then BA[bussiness analyst] will create features out of these requirements.
-> further the feature will be divided into tasks.
-> TL[team lead] will further decides how many tasks can be delivered for that sprint.
-> A sprint usually takes 15days to complete.
-> further TL will assign tasks to developers and developers starts to work upon those userstories after understanding the requirements.
-> all these things are getting done using this JIRA tool.
-> it helps to manage all the development work flow and manange the team efforts.
 
GIT
===
-> it stands for version control system.
-> while working in a project multiple members can be working in a single repository. so GIT helps to manage different versions of code base.
-> it provides different commands to operate over repository.
	git init=> initializes git on a folder/location
	git add=> add files from untracked to staging area
	git commit -m "msg"=> commits our local changes in local repo
	git push=> sends all the local commits to remote repo, it will not send the changes which are not commited in local.
	git pull=> pulls all remote changes to local repo


Q.Can we override constructor?
Ans: In Java, constructors cannot be overridden. This is because constructors are not inherited.But we can overload the constructor.

Q.What is a constructor and why we use?
Ans:Constructor is nothing but a special type of method. We use it for object initialization.

Q.While inherting a class do we inherit constructors?
Ans:You can't override constructors in Java because they are not inherited.

Q.Can we override static method?
Ans:No,whenever we try to override a static method in java, it will lead to hide it.That is known as "method Hiding".

Q.what is serialization?
Ans:In Java, serialization is the process of converting an object into a byte stream so that it can be easily saved to a file, transmitted over a network, or stored in a database. 
->The main purpose of serialization is to allow the object to be persisted or transferred and then later deserialized (reconstructed back into an object) at a different location or time.

Q.1st level and 2nd level cache in hibernate?
Ans:
	1st level cache:
	This is local to session object and can't be share with multiple sessions.
    		  ->This is enabled by default and there is no way to disable it.
              ->This is available only until the session is open.Once the session is closed 1st level cache will be destroyed.
			  
    2nd level cache:
	This is maintained at session factroy level and shared among all the sessions.
              ->This is disabled by default but we can enabled through configurations.
              ->This is available throughout the application life cycle.It is only destroyed and re-created when an application is restarted.

Q. what is design pattern?
Ans:A design pattern is a reusable solution to common software design problems.It provides a structured approach to solve those problems
Types of design pattern:
------------------------
1.Creational design pattern
	->This patterns helps in creating objects in a flexible and reusable manner.
		a.Singleton pattern
		b.Factory pattern
		c.Abstarct Factory Pattern
		d.Builder Pattern
		e.ProtoType Pattern
2.Structural design pattern
	->This pattern helps in organizing classes and objects.
		a.Adapter Pattern
		b.Bridge Pattern
		c.Composit Pattern
		d.Decorater Pattern
		e.Facade Pattern
		f.Proxy Pattern
		g.Fly weight Pattern
3.behavioural design pattern
	->This pattern focus on communication between objects.
		a.Command Pattern
		b.Interpreter Pattern
		C.Iterator Pattern
		d.Mediator Pattern
		e.Observer Pattern
		f.chain of responisibilty Pattern
		g.template method Pattern
		h.stategy  Pattern
		i.visitor Pattern
		j.state Pattern
		k.memento Pattern
		
Q. what is profiles concept in spring boot?why we use it?
Ans:-> profiles refers to different environments like dev, test, prod etc. we can use different configurations for different environments.
->Like, dev-application.properties file.
		prod-application.properties file.
		test-application.properties file.
		
Q. what is fail fast and fail safe collection?
Ans:Collections are divided into 2 types.
	i. Fail fast collection
	->It will throw error immidiately when we modify collection object while iterating the collection.Ex: ArrayList,LinkedList,vector.. etc
	
	ii.Fail safe collection
	->It will not throw any error even if we modify (add/remove) collection object data while iterating. Ex:CopyOnWriteArraayList, ConcurrentHashMap etc..
	
Q. what is ACID properties?
Ans:generally ACID properties we use in database for below properties,
	1.Atomicity: Either all the changes are performed, or
	none of them.
	2.Consistency: Data is in a consistent state when a
	transaction starts and when it ends,;/p;
	3.Isolation: Transactions that run concurrently appear to
	be serialized.
	4.Durability: After a transaction successfully completes,
	changes to data persist and are not undone, even in the
	event of a system failure.

Q.What is SOLID principle or What are the SOLID principles of software design How would you apply these principles in Java development?? 

1.Single Responsibility Principle (SRP):
->The SRP states that a class should have only one reason to change.It means that a class should have a single responsibility or purpose

2. Open-Closed Principle (OCP):
->The OCP states that classes and modules should be open for extension but closed for modification. It means that you should be able to extend the behavior of a class without modifying its existing code. In Java, you can achieve this by using abstraction, interfaces, and inheritance.

3. Liskov Substitution Principle (LSP):
The LSP states that objects of a superclass should be replaceable with objects of its subclasses without affecting the correctness of the program,

4. Interface Segregation Principle (ISP):
The ISP states that clients should not be forced to depend on interfaces they don't use.

5. Dependency Inversion Principle (DIP):
The DIP states that high-level modules/classes should not depend on low-level modules/classes directly.

By using these SOLID principles, you can create more maintainable,flexible,and testable code that is less prone to bug and easier to extend or modify.

Q. delete vs drop vs truncate?
ans: delete: removes rows from a table. it can be rolled back. DML
	 drop: removes a table from database. can not be rolled back. DDL
	 truncate: removes all rows from a table. can not be rolled back. DDL
	 
Q. hibernate vs spring data jpa?
Ans: 
-> Hibernate is a java based ORM tool that provides a framework for mapping application
domain objects to the relational database tables and vice versa.

-> Spring Data JPA is an abstraction layer on top of JPA to Reduce the amount of boilerplate code required to implement data access object (DAO) layer.

-> Hibernate is a JPA provider ( JPA specification implementation). Spring Data JPA is not a JPA provider. It simply "hides" the Java Persistence API (and the JPA provider) behind its repository abstraction.

Q. thread life cycle?
Ans: create >> runnable >> running >> dead
Note: the time period in between this runnable and running states, thread can be put in to sleep(), waiting(), suspend() by jvm. its known as non-runnable state

Q. bean life cycle?
Ans:Container Started >> Bean Instantiated >> Dependencies Injected >> Custom init() method >> Bean is Ready to be used >> Custom utility method >> Custom destroy() method
-> @PostConstruct and @PreDestroy, these annotions used for configuring any methods or configurations before or after bean creation.

Q. explain hashing technique?
Ans:->Hashing is a technique which is used to store the elements in hashset.
->It commonly used in HashMap,HashTable,HashSet

Q.How does HashMap handle collisions internally?
Ans:->HashMap handles collisions using a linked list.
->When multiple keys hash to the same index, they are stored in a LinkedList. 

Q.How would you scale a hotel booking system?
Ans: scaling can be done in two ways.
		1. horizental
		2. vertical
		
Q.How does spring security handle authentication?
Ans: Security contains two things;
	 1. Authorization
	 2. Authentication
	 
Q.Indexing vs.Partitioning-When should you use each?
Ans:
1. index is a data structure (like a B-tree or hash index) that allows the database to quickly locate rows based on the values in specific columns. It works similarly to an index in a book, allowing for faster lookups.

2. Partitioning is the process of splitting a large table into smaller, more manageable pieces called partitions. Each partition holds a subset of the data, typically based on a key (e.g., range of dates, geographic region, or ID range). Partitioning helps in managing large datasets and improving performance in certain cases.

Q.How to optimize API response for high traffic?
Ans:->We can scale the applicaiton horizentally.
->We can make use of load balancers to distribute the load among instances.
->We can use rate limiters for which we can process limited amount of traffic at a time.

Q.What is singleton class in java?
->A Singleton class in Java is a design pattern that ensures a class has only one instance and provides a global point of access to it.
Ans:Step-1:Declare constructor as private.
Step-2:Create a method make it static, which retrun the same class object.
Step-3:Declare same class variable and initialize with null value.

Q.Difference b/w Array and LinkedList
Ans:Array:
    ------
->It is a fixed size data structure.
->Array uses contiguous memory allocation.
->Insertion and deleting is not preferred in array as elemrnts needs to be shifted.
->Accessing element in array is faster.
->Arrays are best suited for small-sized data.
->Array can store primitive data types as well as objects.
LinkedList:
-----------
->LinkedList is dynamic in size.
->LinkedList uses non-contiguous memory allocation.
->Insertion and deletion operations is preferred bexacuse it uses nodes to stored the elements.
->Accessing elements in faster is not preferred here.
->LinkedList are best for big-size data.
->LinkedList can only store objects.

Q.Can we override start() method?
Ans:-> yes, we can override start() method in java.
->We can override start() method to provide our own implementation of thread execution.
->start() method is defined in the thread class and is responsible for starting a new thread of execution.
->However,it is recommended to avoid overriding a start() method and instead use the run() method for custom thread execution.
->Ex: public void start(){//custom implementation}

Q.Can we override main() method?
Ans:->No.As, it is a static method.

Q.Can we overload main() method?If yes, which one will be called?
Option A.public static void main(String[] args)
	   B.public static void main(String name)
Ans: Option A is the one called by the JVM when we start the program.It acts as default entry point. but if we want to execute the second method then we have to call the 2nd method from inside 1st method.
example:
===========
public class MainOverload {
    public static void main(String[] args) {//default entry point for JVM
        System.out.println("This is the default main method.");
        main("Overloaded main method called!");
    }

    public static void main(String name) {
        System.out.println(name);
    }
}

Q. if we can not instantiate abstarct class then what is the role of constructor present inside it?
Ans: constructor is used for initializing objbect.

Q.Diff. b/w @Primary and @Qualifier
Ans. 
-> we can provide bean names by using this @Qualifier annoation.
->  while calling overloaded beans(basically it refers to overloaded methods with @Bean annotaion), we can set which one should be Primary.

Q.What is class loader
Ans: refer JVM architecture.

Q.What is Garbage collector and how it works?
Ans: its a program present inside JVM's execution engine, which freeups the space by removing unassigned, unused objects.
->It prevents memory leaks and optmize memory usage.

Q.I want to add element inside a collection where duplicates won't be allowed and insertion order also be preserved.What should i use?
Ans: we can use Set type collection. it doesnot allows duplicate elements. as we want to preserve insertion order we can use LinkedHashSet.

Q.Diff b/w limit() vs skip().
Ans: both used in stream api.

Q.Spring bean scopes
Ans: 1. singleton 2. prototype
1. singleton always returns same object everytime.
2. prototype returns new object everytime.

Q.Why static and default methods are added inside interfaces?
Ans: to add a concrete method inside interface we can have these static or default method.

Q.Stream vs parallel stream
Ans: Stream process a collection using single thread whereas parallel stream takes help of multiple threads to process.

Q.Which should be preferred b/w String and StringBuffer when there are many updates required to the data.
Ans: StringBuffer will be preferred as it allows string modification without creating multiple string obejcts.

Q.What is @Configuration and @bean?
Ans: 
@Configuration: it declares that the class is containning some configurations. its a class level annotaion. its used enable annotation based configuration.
@Bean: it used to create beans or objects.its a method level annotaion.

Q.What is IOC in spring
Ans: IOC stands for inversion of control, that means the object creation power will be given to spring container.

Q.Dependecy injection and it's type
Ans: dependency injection means we can inject a class object into another class.
we can achieve it using @Autowired.
it is 3 types. 1. field injection 2. setter injection 3. constructor injection

Q.how database configuration in spring boot
Ans: by using application properties file we can provide all the database related configurations like database creds(username,password, url,driver), hibernate properties(hbm-ddl=auto),jpa properties

Q.What is type of joins and it's work.
1. caretsian join or natural join
2. left outer join
3. right outer join
4. inner join

Q.Diff b/w Runnable inteface and callable inteface
Ans:->Runnable is for tasks that dont need to return a result or throw exceptions.
Ex:void run();
->Callable is for tasks that need to return a result and can throw exceptions. It's more flexible.
Ex:<return type> call() throws Exception;

Q.How do u enable debugging logs in a spring boot application?
Ans:By using log4j/@Slf4j we can enable logs.

Q.What is the default port of springboot and how to change?
Ans:8080 is default port number and we can change it in applicaiton properties file by using server.port=<new port number>

Q.Waht is System.out.println?
Ans:System:It is a class
->System.out: Refers to the standard output stream (the console).
  println(): Prints the text followed by a newline.
->So, when you write System.out.println("Hello, World!");, it sends the string "Hello, World!" to the console and then moves the cursor to the next line, so any subsequent output will appear below it.

Q.Diff. b/w sleep and wait method
-> sleep()- Pause the current executng thread, for a specific time.
	wait()- Mix the thread wait until it's notified.Used in inter thread communication.

Q.Whta is flatMap?
Ans:->flatMap() is used in stream.
->flatMap is a intermediate function.
->We use flatMap to convert 2D array into single dimensional array.

Q.What annoation you use to handle the exceptions?
Ans:@ControllerAdvice

Q.What is the use of transient keyword in java?
Ans: While serializing a class if we make a property a transient, then that particular property will not be serialized.
->If we don't want to inject a property inside class, in that case also we can mark that property as transient.
->Ex:transient String name

Q.List of primitive and non-primitive data types default value
Ans: primitive:
	 byte-0
	 short-0
	 long-0L
	 int-0
     float-0.0f
	 double-0.0d
	 boolean-false
	 char-''
	 non-primitive
	 Arrays:null
	 String:null
	 Object:null 
	 
How and why we are using JPA?
Ans:JPA stands for Java Persistence API.
->Earlier we were using JDBC for doing the connection b/w java and database but there were some problem occured, known as ORM problems.
->To overcome those problems, JPA standards came into picture. It provided some rules and regulations. Hibernate framework followed those JPA standards and provided solutions to ORM problems.
->Then Spring data JPA came into picture. It provided an abstraction layer to Hibernate framework implementations.
->Spring data JPA conatins different repositories.JPARepository,PagingAndSorting Repository,CrudRepository. Different repositories contains different methods to perform database operations.

Q.How we can optimize the performance of an endpoint(explain in terms of caching).
Ans: By using caching mechanism we can improve the response time of an endpoint as well as the database hittting can be reduced.
-> For this we can use Redish Cache.
-> We can introduce one extra layer before database known as cache layer.
->@Cachable, @CacheEvict, @CachePut

Q.What is @Transactional
->@Transactional is an annotation used in Spring Framework (Java) to manage transactions declaratively.
->When you annotate a method or class with @Transactional, Spring does the following:
	1.Starts a database transaction before the method executes.
	2.Commits the transaction if the method completes successfully.
	3.Rolls back the transaction if a runtime exception (unchecked exception) occurs.
->Points to remember here-
	i.Only public methods are transactional by default.
	ii.You need to have Springs transaction management enabled (via @EnableTransactionManagement or auto-config in Spring Boot).

Q.How we can configure config server.What is the benefit of using it in a microservice application
Ans:Step-1:We have to add config server dependency in pom.xml file
Step-2: We have to add github properties in key value pair in application.properties file
Step-3:in main class we have to add @EnableConfiServer annotation.
Benefit:
->Config server contatins config server dependency and another microservice contains config dependency.
->microservice send request to config server and config server send that to github repo.
->Github repo contains all common configuration properties in key value pair in application.properties file.
->Then, Github repo will send those properties as response to config server and confi server will send that to microservice.
->For example: we are having 5 microservices and for each microservice we have JPA and database connection properties. SO, instead of writing these properties in each microservice, we will write these common properties in github repo and make use of it when it required.

Q. what is the use of api gateway?
Ans:When a request coming from user to server, API gate way is the 1st microservice to validate that request.
->It will check for header,cookies,authentication etc.. If the request is structurally corrdct, it will send that request to eureka server as microservice doesn't contain microservice details.
->Eureka sever process that request and send microservice details for that particular request as a rsponse to API Gateway.
->Then API Gateway will route that request to  that particular microservice.
->Api gateway works a s a gatekeeper or entry point to our microservice.
->Api gateway contains 3 components.i.Router-which route the request ii.SSO-It works a s a authenticator or security purpose iii.filter- it helps to check header,cookies etc..

Q. what is the role of eureka server?
Ans:->Every microservice needs to register at one place.That is known a seureka server.
->It works as  registry or discovery purpose.
->It contains all the details about microservice like:port number, number of instance etc..
->It helps api gateway to locate the microservice.

Q. do you know about distributed logging mechanism in microservice application?
->For distributed logging mechanism in microservice application we are using Zipkin and sleuth.
->When a request is going through various microservices, to known the flow, we need to  track that request and for this we have zipkin and sleuth.
->To known the entire flow of a microservice we need one unique id and that is known as Trace id.
->To know individual microservice log information, we need one id and that is known as Span id.
->In each microervice we need to add two dependencies i.e sleuth and zipkin client.
->Sleuth is a dependency which is present in each microservice and it helps to generate the log information.
->Zipkin client will collect those log information from sleuth and send it to zipkin server.
->Zipkin server is the central server which collects all the data coming from zipkin client and shows it in a dashboard.

Q. how to communicate in microservice environment?
Ans:For communicate in microservice environment, we are having RestTemplate, activeMQ and kafka.
->RestTemplate following syncronous way of communiction.In this s when we send a request, we have to wait for that response from producer before initiating another request.
->It follows producer and consumer concept, where consumer send request to producer and producer send response.
->ActiveMQ and Kafka follows asynchronous way of communication.In this communiction when we send a request we don't have to wait for response to initiate another request.
->For conuming diff. types of endpoints while implimenting a RestTemplate, we are having different methods which we can use in consumer application to consume the responses.
  *POST type we can use it for PostForEntity method at consumer.
  *GET  type endpoint we use for GetForEntity method at consumer.
  *for PUT,PATCH and DELETE endpoints we can use exchange method at consumer.
  
Q. explain hibernate steps?
Ans:There are 4 steps in hibernate.
i.Configuration
	->It provides mapping information.
	->It produces connection properties.
	->Gives reference to SessionFactoryectory
ii.SessionFactory
	->It configures db
	->manages conncetion information
	->Gives reference to Session.
iii.Session
	->Here we are doing CRUD operation.
	->It is the live connection b/w applicaiton and database.
	->Goves reference to transaction
iv.Transaction
	->it uses for commit/rollback
	->The database operation in which, database gets updated structurally then that is known as Transaction.Ex:save,update,delete methods.

Q.Can a constructor inherited from a parent class to child class.
Ans:->In Java, constructors are not inherited from a parent class to a child class. However, a child class can call a parent classs constructor using the super() keyword.
->Constructors are special type of method used for object initialization.
->constructors are not regular methods, they cannot be inherited.But when you create an object of a subclass, the constructor of the parent class is automatically called (either explicitly with super() or implicitly).

Q.Create a student class and and create a list of student.Write a program in java 8 to filter all students with rollno>50, concatenate their first and last name.
Ans:Refer Test1.java in STS.
		
Q.Create a CRUD Application,How would you start?What classses would you create and which annotation would be needed?
Ans:I will start with adding dependencies in pom.xml file, there i will add lombok,spring web,Spring JPA and for database connection mysql-connector dependencies etc...
->Then in application.properties file we ill add servert port number,for database  opearation will use database properties such url,username,password,platform name and will add JPA properties.
->we will create model class , repository interface,service interface, service implementation class,controller class.
->in model calss we will use @Getter for get the user value, @Setter for set the user details, @ToString for print the object, @Entity for make the class as an entity, @Table for create a table name, @Id for declare a field as primary key, @GeneratedValue for generate id automatically and so onn.. 

Q.Are you familiar with design patern? Explain
Ans:A design pattern is a reusable solution to common software design problems.It provides a structured approach to solve those problems.
Types of design pattern:
------------------------
1.Creational design pattern
->This patterns helps in creating objects in a flexible and reusable manner.
		a.Singleton pattern
		b.Factory pattern
		c.Abstarct Factory Pattern
2.Structural design pattern
->This pattern helps in organizing classes and objects.
		a.Adapter Pattern
		b.Bridge Pattern
		c.Composit Pattern
3.behavioural design pattern
->This pattern focus on communication between objects.
		a.Command Pattern
		b.Interpreter Pattern
		C.Iterator Pattern
		d.Mediator Pattern

Q.What are java 8 features introduced in java?Diff. b/w lambda expression and functional interfaces.
Ans:Features introduced in java 8:
i.Lambda expression
ii.Functional interface
iii.Method reference
iv.Constructor reference
v.New Date and Time Api
vi.Default method in inteface
vii.Static method in interface
Diff b/w lambda and functional interface.
lambda:
->It is an annonymous function.
->It has no name,no return type,no access modifier
->In java upto 1.7, java supported only object oriented approach but java 1.8 towards by the help of lambda expression and functional interface java supported functional programming approach.
->Functional programming:java 1.8 onwards, java supported functionas as an argument to another function.
->exa of lambda: public static void m1(){System.out.println("Hello")};= ()->System.out.println("Hello");
Functional interface:
->Interface which have only ne abstract method is known as functional programming.
->Functional interface is used to invoke/call lambda expression.
->Java provided soem pre-defined functional interfaces.
i.Predicate:test(T t)
ii.Supplier:get(T t)
iii.Consumer:accept(T t)
iv.Function:apply(T t)

Q.What is an optional class in java?
Ans:->Optional class used to handling null.
->If a method returns null value, it is possible that upcoming methods may get fail and will throw nullpointerexception.So,to prevent this we use optional class.	 

Q.How do we achieve serialization and where do primitive types take up memory?
->Serialization is a process which is use to converting object into byte Stream.So, that it can bse saved into a file, transfer over network and stored in database.
->The main purpose of serialization is to transfer the object and later de-serialized.

Q.What is multithreading?How do you create threads.
Ans:Multithreading is a process of execution of more than one thread at a time.
->In multithreading threads are sharing a common resource and memory.
->We can perform many operations together.So, it saves our time.
->Threads are independent, so if exception occurs in one thread, it will not effect other threads.
->A thread is a piece of code which executes independently.
->Thread class is present in java.lang package.
->A thread can't be created more tahn once.If we try to do it will throw IllegalThreadStateException.
->Threads are 2 types.i. Deamon thread ii.Non-deamon thread.
->Deamn threads are kow priority threads which perform low priority tasks.
->JVM don't give much importance to this.
->Ex:Updating data, checking for updates etc..
->Non-deamon threads are high priority threads which doing high priority tasks.
->JVM gives much importanceto this.
->This thread used to carry main tasks.
->We can set a thread is deamon or non-deamon based of it's parent thread.if parent thread is deamon it will be deamon otherewise it will be non-deamon.
->We can set a thread as deamon by using "set Deamon is true"
->We should set the thread type before starting it.
->Thread can be created in 2 ways. i.By extending thread ii.By implementing Runnable interface.

Q.Diff. b/w comparator and comparable.
Ans:Comparable:
->Comparator contains compareTo().
->It has only one argument.
->It compares with the supplied or input argument.
->It's present in java.lang package.
->It follows natural ordering.
->Comparable should be implemented in same class.
Comparator:
->Comparable contains compare().
->It has two arguments.
->It compares two arguments.
->It's follows in customize ordering.
->It present in java.lang.util package.
->Comaparator can be implemented from any class.

Q.When should we use a List and when should we use a set.
->If we want to store duplicate elements we can go for List, if we don't want to store dulicate elements we should use set.
->If we want to follow insertion order we should use list, else we should use set..

Q.When should we use a List and when should we use a map.
Ans:If we want store elements in key value pair.we ahve to use map otherwise we will use List.

Q.How can we create a custom exceptions?
Ans:1st we have to create custom exception class by extendng RunTimeException or exception class.
Q.How can we handle exception globally in springboot
Ans:1st we have to create custom exception class by extendng RunTimeException or exception class.
->Then we have to create one class with annotation @RestControllerAdvice.
->Then we have to create exceptionHandler methods by using annotation @ExceptionHandler.then we have to provide <customException>.class as input.
->Ex:
	@RestControllerAdvice//this class will be used for handle custom exceptions
		public class HandleCustomExceptions {

	@ExceptionHandler(CarDetailsNotFoundException.class)
	public ResponseEntity<String> handleCarDetailsNotFoundException(
			CarDetailsNotFoundException carDetailsNotFoundException) {
		return new ResponseEntity<>(carDetailsNotFoundException.getMessage(), HttpStatus.BAD_REQUEST);
	}
	
Q.What is wrapper class nd their advantgae in java?
Ans:In Java, a wrapper class is a class that wraps (or encapsulates) a primitive data type into an object. Java provides wrapper classes for all eight primitive data types:

Primitive Type	Wrapper Class
byte			Byte
short			Short
int				Integer
long			Long
float			Float
double			Double
char			Character
boolean			Boolean

Advantage:
---------
1.Used in Collections (like ArrayList, HashMap):
------------------------------------------------
->Collections in Java store objects, not primitives. So if you want to store an int in an ArrayList, you need to use Integer.

2.Autoboxing and Unboxing:
--------------------------
->Java automatically converts between primitives and their wrapper objects:
	Autoboxing: converting primitive  object
	Int a = 5; Integer obj = a;

	Unboxing: converting object  primitive
	Integer obj = 5; int a = obj;
	
3.Utility Methods:
---------------------
->Wrapper classes provide helpful methods, like:
int num = Integer.parseInt("123"); // converts String to int

4.Null Values Support:
-----------------------
->Wrapper objects can be null, whereas primitive types cannot. This is useful when you need to represent the absence of a value.

5.Type Conversion:
-------------------
->Wrapper classes can convert between different number types or strings:
Double d = Double.valueOf("3.14");
int i = d.intValue(); // converts to int

Q.Diffe. b/w String, StringBuffer and StringBuilder
Ans:String:
->It is immutable in nature.
->We can't change the value.
->Any operation like concat(), replace(), or substring() creates a new object.
StringBuffer:
->It is muttable. we can change the content without creating a new object.
->It is thread safe as it's all methods are synchronized.
->It is slower then StringBuilder.
StringBuilder:
->It is also muttable like StringBuffer.
->it's not thread-safe bcoz all methods are not synchronized.
->It is faster than StringBuffer.

try{
}
catch(Exception e){
}
finally{
try{
}
catch(Exception e){
}
}

Questions to be anwered.
-------------------------
1.Diff. b/w SQL and NoSQL
Ans: SQL->Structured Query Language.
	->It has Fixed schema (structured).
	->vertical scalability.
	->It consists Tables (rows & columns)
	->Ex:MySQL, PostgreSQL, Oracle
	NOSQL->Not Only Structured Query Language
	->It has Flexible or schema-less.
	->Horizontal scalability.
	->It consists Documents, key-value, graph, etc.
	->Ex:MongoDB, Cassandra, Redis
	
2.How do you implement security?and how does OAuth work?

3.How do you connect a microservices?
Ans:Ways to connect a microservices:
1.Rest API(Most commom)
->In this synchronus way of connection happen.
->Services communicate over HTTP using REST endpoints.
->Lightweight and easy to implement.
->Tools: RestTemplate, WebClient
2.Asynchronous (Message queues):
->Services send messages via brokers (non-blocking).
->Useful for decoupling and high scalability.
->Tools: RabbitMQ, Kafka, ActiveMQ
3.Service Discovery
->Automatically find services without hardcoding URLs.
->Tools: Eureka, Consul, Zookeeper
4.API Gateway
->Central entry point for all clients.
->Routes requests to appropriate microservices.
->Also handles logging, rate-limiting, authentication.
->Tools: Spring Cloud Gateway

4.How would you implement security? What is @EnableWebSecurity?

5.How to create immutable classes?
Ans:Create muttable class in java means, creating a class whose value will not be change after creating object.
->Steps to Create an Immutable Class:
1.Make the class final  so it can't be subclassed.
2.Make all fields private and final.
3.Dont provide setters  only getters.
4.Initialize all fields via constructor.

6.explain your project and day to day work.
Ans:->i was in an insurance domain project. it was a microervice based project with several services. i was assigned with registration module, where we were taking user input at the frontend and processing it at backend using java, jdbc, hibernate, spring, spring boot,microservices. on day to day basis i log into jira for the assigned tasks and understand the userstory and tasks, teamlead will provide the insights of the assigned task and i ll proceed further for development work. like wise will take care of junits and stage deployment work further.

7.How Hashmap works internally and Diff. b/w HashMap and ConcurrentHashMap
Ans:->It Uses hashing (hashCode()) to locate data quickly.
->Handles collisions using a LinkedList or TreeNode (since Java 8).
Diff. b/w HashMap and ConcurrentHashMap:
HashMap:
->It's not thread-safe.
->Allows 1 null key & many null values.
->Peformance is Fast in single-threaded apps.
->Used in Single-threaded environment.
ConcurrentHashMap:
->It's thread-safe.
->It Does not allow null keys or values.
->Performance is Better in multi-threaded apps.
->Used in Multi-threaded environment.

8.How do you handle stress situation in your project?
-> generally 
9.Where do you see yourself after 5 years.

10.What value you will add if we hire you.

11.Diff b/w .ear, .jar and .war files.
Ans:.ear stands for enterprise ARchive
   ->It contains .jar + .war files.
   ->used in Java EE servers (JBoss, GlassFish)
   .jar stands for Java ARchive.
   ->It contains .class files, resources.
   ->Used in Java SE / any app.
   .war stands for Web application ARchive.
   ->It contains JSP, Servlets, HTML, .class, .jar.
   ->It used in Web servers (Tomcat)
   
12.Diff b/w save and saveorupdate.
Ans: save():
->Purpose of save() is it Inserts a new record only.
->It Returns generated ID.
->used in When inserting new data.
saveOrUpdate():
->Pupose of saveOrUpdate() is it Inserts or updates based on object state.
->It Returns void.
->used When youre not sure if its insert or update

13.What is @Controller annotation.How can you create a controller without an annotation?
Ans:->@Controller annoation is used in controller layer.
->It is used to declare a class as a controller.
You can create a controller without annotations by:
->Implementing Controller interface
->Registering it via XML or Java config

14.Diff. b/w view and partial view.
15.How does an exception propagate in a code?
16.what is merge() of the hibernate session?
17.How can we inject a regular POJO into ISC containers.
18.What is Aggregation and composition.
19.diff b/w heap and stack memory.
20.How can we find the frequency of each character using java 8?
21.Reverse vowels of a string.
22.	find employees grouped by department.
23.In java how many ways we can create a object?
Ans: 2 ways. 1. By using new keyword, by using class.forname()

Notes:
-> a basic project is having different environments like dev/stage, QA/test, -> prod/Production etc.

Q. how to provide different properties to applcation in different environments[dev,qa,prod]?
Ans: by using profiles concept we can use different properties in different environment.
example: application.properties => default
		 dev-applcation.properties => dev
		 qa-applcation.properties => qa
		 prod-applcation.properties => prod
to enble these application properties files wrt evns we have to add 
spring.profiles.active=dev or qa or prod
into default applciation properties file.

Q. spring aop define?
A. spring aop is a module in spring framework, by using which we can segregate cross cutting functionalities like logging, from business logic.