interview prep:-
====================
JAVA:-
============
OOPS[object oriented programming]
----------------------------------
Note: 
* variables=>properties, fields
* methods=>behaviours, functions
* in java every classes extends Object class by default.

1.Inheritance
--------------
->Acquiring properties from parent class to child class.
-> type
a. single inheritance-> one parent and one child class
b. multiple inheritance-> not supported (in terms of classes not supported, in terms interface supported)
c. multilevel inheritance-> one child, one parent, one grand parent class...... and so on
d. cyclic inheritance-> inter dependent classes
=> in terms of classes, java doesnot support multiple inheritance. it causes diamond problem thats why.
diamond problem: as object class is parent of every other class, when we create a child class named Vehicle, which extends two parent classes as Car, Bike.
                 Both parent classes are having a method as start(). in this scenario the java compiler will get confuse which start() method to be called.

2.Polymorphism
----------------
-> same name but different behaviour
example:- 
public int add(int a, int b){return a+b;}
public String add(String a, String b){return a+b;}
-> types
a. Compile time polymorphism-> method overloading( in same class, multiple methods with same name and different arguments)
b. Run time polymorphism-> Method overriding (in different class, multiple methods with same name and same arguments)

3.Abstraction
--------------
-> Hiding unwanted implementation and providing useful methods.
-> By using abstract classes and interfaces we can achieve abstraction.
-> If a class contains atleast one abstract method, then that class is known as abstract class.
->Abstract method- a method without implementation is known as abstract method. ex: public void engineStart();

4.Encapsulation
----------------
-> Binding properties and behaviours in a single unit.
-> To achieve encapsulation we have to declare all the properties/variables/fields as 'private' and to access those we have to provide public methods, known as setters and getters.

-----------------------------------------------------------------------------------------------------------------

Example of

1. Inheritance
----------------

class Vehicle{
 	String type;
 	int identficationNumber;
}

class Car extends Vehicle{
	String company;
}

class Tata{
}
public class InheritanceExample{
	public static void main(String[]args){
		Vehicle v=new Car();
		car c= (Car) v;
	sout.println(c.company);

}
}

2. Abstraction
----------------

package com.InterviewPractice;
abstract class Animal{

	String animalType;

	public void wildAnimal(){
	
	System.out.println("wild animal spotted");

	}

	public void domesticAnimal(){
	
	System.out.println("domestic animal spotted");

	}
	
	abstract public String animalStructure();

}

class Dog extends Animal{
	private int legs;

	public void wildAnimal(){
	
	System.out.println("wild animal spotted");
	}
	
	public String animalBehavior(){
		
		System.out.println("animals barking");
		return "animalBehavior";
	}
	@Override
	public String animalStructure() {
		System.out.println("abcd");
		return "animalStructure`";
	};

}
public class Abstracton {
	public static void main(String args[]){
	Animal a1=new Dog();
	a1.domesticAnimal();
	a1.wildAnimal();
	System.out.println("-----");

}
}

3. Encapsulation:
-----------------
package com.InterviewPractice;

class Bank{
	private String userName;
	private int userId;
	private String userAddress;
	
	public void setUserName(String name) {
		this.userName=name; //this keyword is used to refer same class non static variable.
	};
	public void setUserId(int id) {
		this.userId=id;
	}
	public void setUserAddress(String add) {
		this.userAddress=add;
	}

	public String getUserName() {
		return userName;
	}
	public int getUserId() {
		return userId;
	}
	public String getUserAddress() {
		return userAddress;
	}
	public String toString() {
		return userName+" "+userId+" "+userAddress;
	}
}
public class Encapsulation {
	public static void main(String[]args) {
		Bank bank=new Bank();
		bank.setUserName("Raju");
		bank.setUserId(2024);
		bank.setUserAddress("bbsr");
		System.out.print(bank);;
		
//		System.out.println(bank.getUserName());
//		System.out.println(bank.getUserId());
//		System.out.println(bank.getUserAddress());
	}
}

4.Polymorphism:
---------------
package com.InterviewPractice;

//note- resolving method call at compile time is known as compile time polymorphism.
// resolving method call at run time is known as run time polymorphism.
class Watch{
	void digital() {
		System.out.println("buying digital watch");
	}
	void digital(int a) {
		System.out.println("buying two "+a+" set digital watch");
	}
}
class DigitalWatch extends Watch{
	@Override
	void digital() {
		System.out.println("buying new digital watch");
	}
}
public class Polymorphism {

	public static void main(String[] args) {
		Watch w=new Watch();
		w.digital();
		w.digital(2);
		
		DigitalWatch d=new DigitalWatch();
		d.digital(); 

	}

}


Exception Handling:
-------------------
-> Unwanted termination/abroption of program during normal execution is known as exception.

Types:
------
1.Unchecked exception/Run-time exception
----------------------------------------
-> The exception which can't be checked by compiler at compile time.
-> ex: ArithmaticException, NullPointerException, IndexOutOfBoundException, ClassCastException

2.Checked exception/Compile-time exception
------------------------------------------
-> The exception which can be checked by compiler at compile time.
-> ex: ClassNotFoundException, IOException(FileNotFoundException, InterruptedIOException), SQLException

--> Exception can be handlled using 1. try........catch block 2. throw and throws 3.finally block

example:1
---------------
try...catch block
----------------------
class Math {
public static void main(String[] args) {
      int a = 100;
      int b = 0;
try{
      int c = a/b;
      System.out.println(c);
} catch (Exception e) {
      System.out.println(c);
}
}
}
example:2
---------------
package com.InterviewPractice.exception;

public class ExceptionHandlingExample {

	public static void main(String[] args) {
		int a = 100;
		int b = 0;
		int c = 0;
//		try {
//			c = a / b;// risky code
//		} catch (ArithmeticException e) {
//			System.out.println("inside ArithmeticException's catch block");
//		} catch (Exception e) {
//			System.out.println("inside Exception's catch block");
//			c = c + 15;
//		} finally {
//			System.out.println("thank you");
//		}
		try {
			c = a / b;// risky code
		} catch (ArithmeticException | NullPointerException e) {//multiple exceptions can be present inn a single catch byusing "or" operator.
			System.out.println("inside catch block");
		} finally {
			System.out.println("thank you");
		}
		System.out.println(c);
		System.out.println("working");
	}

}
note: multiple catch with a single try block can be written. but the exceptions should be handled from child to parent type.

throw..........throws keyword:
-------------------------------
-> throw is used to create new exception where as throws is used to declare an exception.

example:3
-----------------
package com.InterviewPractice.exception;

//checked exception example
class DemoException extends Exception {
	DemoException() {// constructor
		System.out.println("car exception occured");
	}

	DemoException(String msg) {
		System.out.println(msg);
	}
}

//unchecked exception example
class Demo2Exception extends RuntimeException {
	Demo2Exception() {// constructor
		System.out.println("car exception occured");
	}

	Demo2Exception(String msg) {
		System.out.println(msg);
	}
}

public class ThrowAndThrowsExample {
	public static int division(int a, int b) throws DemoException{
		return a / b;
	}

	public static void main(String[] args) {
		int a = 100;
		int b = 0;
		try {
			if (b == 0) {
				throw new Demo2Exception("exception occured");
			}
			int result = division(a, b);
			System.out.println(result);

		} catch (DemoException | Demo2Exception e) {
			System.out.println("inside catch block");
		}
		System.out.println("abc");
		System.out.println("abc");
		System.out.println("abc");
		System.out.println("abc");
	}
}
---------------------------------------------------------------
multithreading:
------------------
-> thread can be created 
1. by extending Thread class
2. by implementing Runnable interface

example:1
-----------
package com.InterviewPractice.multithread;

//String userName;//varibale
//String userName();//abstract method
//String userName(){};//concrete method
//new UserName();//class obejct creation

class MyThread1 extends Thread{//creating thread using Thread class
	public void run() {
		for(int i = 1; i<=100;i++) {
			System.out.println(i);
		}
	}
}

class MyThread2 implements Runnable{//creating thread using Runnable interface

	@Override
	public void run() {
		for(int i = 1001; i<=1100;i++) {
			System.out.println(i);
		}
	}
	
}

public class MultithreadingExample {
	public static void main(String[] args) {
		MyThread1 t1 = new MyThread1();
		t1.start();
		
		MyThread2 t2 = new MyThread2();
		Thread myThread = new Thread(t2);
		myThread.start();
		
	}
}

-> in programming we are having multi tasking. this can be of two types. 
1. multiprocess: multiple processes like playing video on vlc media, working on ide, listening music etc we can do simultaneously. this is know to be multiprocess
	process: process ia an independent task. its is having its own resources and memory. example:vlc media, working on ide, listening music etc
2. multithreading:carrying multiple tasks in a single process with the help of multiple threads is known as multithreading.
	-> in multi threading all the threads are sharing a common resource.

Thread: thread is an independent path of execution. thread is a light weight process. Thread class is present inside java.lang package.

-> A thread can not be started more than once. if we try to do so then it will throw IllegalThreadStateException.
Types of thread:
1. Deamon thread:
	-> these are low priority threads which performs low priority tasks like checking for updates, maintaining history/backups etc..
	-> JVM does not give much importance to these types of threads.
2. non deamon thread:
	-> these are high priority tasks used to carry the main tasks. JVM gives much importance to it.example: main thread in an java programm(refers to main method)
-> by default a thread is deamon or non deamon that is depends on parent thread. if parent thread is deamon then child thread will also be a deamon thread.
-> we can set a thread as deamon by using "setDeamon() as true".
-> we should set the thread as deamon or nondeamon before starting it.
Thread priority:
-> every thread has priority level. it veries from 1 to 10. 1 means low 10 means high.
-> based on the priority of a thread, thread scheduler schedules the thread execution.
-> by default a thread priority is same as the parent thread's priority.
-> main threads priority is 5.
-> we can set a threads priority by using setPriority() method.
------------------------------------------------------------
Collections Framework:
------------------------
1. List:
---------
(i) ArrayList:
--------------
-> It is the array representation of list implementation class.
->it allows duplicate elements as it implements list interface.

package com.InterviewPractice.collection;

import java.util.*;

public class ArrayListEx {

	public static void main(String[] args) {
		ArrayList <Integer> al=new ArrayList<>();
		al.add(15);
		al.add(65);
		al.add(58);
		al.add(76);
		System.out.println(al);
	}

}

(ii) LinkedList:
-----------------
-> It is the linked representation of list implementation class.
-> it allows duplicate elements as it implements list interface.
-> stores elements in insertion order.

package com.InterviewPractice.collection;

import java.util.*;

public class LinkedListEx {
	
	public static void main(String[] args) {
		LinkedList <Integer> ll=new LinkedList<>();
		ll.add(25);
		ll.add(64);
		ll.add(51);
		ll.add(88);
		System.out.println(ll);
	}

}

2. Set:
--------
(i) HashSet:
------------
-> it is an implementation of hashing technique with array representation.
-> it doesnot allow duplicate elements as it implements set interface.
-> it's an unordered set because here insertion order is not preserved.

Hashing:
---------
-> it is a technique which allows insertion, deletion and find operations in a constant average time.

package com.InterviewPractice.collection;

import java.util.*;

public class HashSetEx {

	public static void main(String[] args) {
		HashSet <Integer> hs=new HashSet<>();
		hs.add(50);
		hs.add(65);
		hs.add(47);
		hs.add(15);
		System.out.println(hs);

	}

}

(ii) LinkedHashSet:
---------------------
-> It is an implementation of hashing technique with linked representation.
-> Here, insertion, deletion order is preserved because it is an ordered set.
-> it doesnot allow duplicate elements because it implements set interface.

package com.InterviewPractice.collection;

import java.util.*;

public class LinkedHashSetEx {

	public static void main(String[] args) {
		LinkedHashSet <Integer> lhs=new LinkedHashSet<>();
		lhs.add(54);
		lhs.add(35);
		lhs.add(77);
		lhs.add(85);
		System.out.println(lhs);


	}

}

(iii) TreeSet:
---------------
-> It is an implementation of binary search tree technique with linked representation.
-> it doesn't allow duplicate values as it implemets list interface.
->all elements are sorted because it is a sorted set.

Binary search tree:
--------------------
->A binary tree said to be a binary search tree if it follows the following rules.
i. if the element is less than root element then it must be in left sub tree.
ii. if the element is greater than root element then it ust be in right sub tree.

package com.InterviewPractice.collection;

import java.util.*;

public class TreeSetEx {

	public static void main(String[] args) {
		TreeSet <Integer> ts=new TreeSet<>();
		ts.add(21);
		ts.add(89);
		ts.add(44);
		ts.add(82);
		System.out.println(ts);


	}

}

(3) Queue:
-----------
->it is an implementation of queue data structure.
->It follows FIFO principle
->it allows insertion in rear end only.
->it allows deletion in front end only.

(i) Priority Queue:
--------------------
-> in priority queue lease element is the highest priority.
-> it allows duplicate elements.
->Here offer() method is used to insert the elements and poll() method is used to delete the elements.
->here, insertion order is not preserved.

package com.InterviewPractice.collection;

import java.util.*;

public class PriorityQueueEx {

	public static void main(String[] args) {
		PriorityQueue <Integer> pq=new PriorityQueue<>();
		pq.offer(56);
		pq.offer(65);
		pq.offer(98);
		pq.offer(10);
		pq.offer(25);
		
		System.out.println(pq);
		System.out.println(pq.poll());
		System.out.println(pq);
		System.out.println(pq.poll());
		System.out.println(pq);

	}

}

(ii) Array Deque:
------------------
-> It is an implementation of double ended queue data structure with array representation.
-> it allows duplicate elements.
->it allows both insertiona and deletion at both the end, as it implemnts dequeu interface.

package com.InterviewPractice.collection;

import java.util.*;

public class ArrayDequeEx {

	public static void main(String[] args) {
		ArrayDeque <Integer> ad=new ArrayDeque<>();
		ad.add(20);
		ad.add(84);
		ad.add(49);
		ad.add(62);
		System.out.println(ad);
	}

}

Interface:
-----------
-> in interface all the variable are by default public static final and methods are public abstract.
-> Every interface itself an abstract.
-> Interfaces can't be instantiated.
-> Interface can be inherited into a class by using implements keyword.
-> Interface can also be inherited into another inteface by using extends keyword.
-> Whenever interface is inherited then all abstract methods of an interface must be overridden in a sub class or sub class must be declared with abstract keyword otherwise compile time error occurs.
-> an interface can contain concrete methods known as default methods.
-> as default methods introduced in java 1.7, to provide support to the older versions we have to provide "default" keyword as prefix to the concrete methods,
   this is known as "backward compatibility".

example:
================
package com.InterviewPractice;

interface Bike {
	void speedUp();//abstract method

	default void electricSupport() {//concrete method
		System.out.println("Electric support provided");
	}
}

interface ElectricBike {
	void roboticBike();
}

class Remote implements Bike, ElectricBike {//multiple inheritance
	@Override
	public void speedUp() {
		System.out.println("speed increased");
	}

	@Override
	public void roboticBike() {
		System.out.println("Robotic bike has started");
	}
}

public class Interface {

	public static void main(String[] args) {
		Remote r = new Remote();
		r.speedUp();
		r.electricSupport();//calling default method
		r.roboticBike();
		
	}

}
--------------------------------------------------------------------------------------------------------------------------------------------------------

Java 8 features:
----------------
1. new Date and Time api
2. Lambda expression
3. Functional interface
4. Stream API
5. Default methods in interface
6. Static methods in interface
7. Method reference
8. Constructor reference.
---------------------------------
1. Lambda expression:
--------------------
-> Lambda is an annonymous function.
-> it has no name, no accesss modifier, no return type.
->in java upto java 1.7, java was supporting only object oriented programming approach. then from java 1.8 onwards by the help of lambda expressions,
 functional interfaces, java supported "functional programming" approach.
->Functional Proframming- java 1.8 onwards, java supported functions as an argument to another function. This is known as functional programming.

example: 
public static void m1(){System.out.pritln("hello")}; => () -> System.out.println("hello");
public static int m2(int a, int b){return a+b}; => (a, b) -> a+b;
public static void m3(String name){System.out.pritln(name)}; => (name) -> System.out.println(name);

2. Functional interface:
-----------------------------
-> an interface which having only one abstract method is known as functional interface.
-> functional interface is used to invoke/call lambda expression.

example:
package com.InterviewPractice.example;

//with lambda expression
@FunctionalInterface
interface Car{
	void startEngine();
}
public class LambdaExpressionExample {
	public static void main(String[] args) {
		Car c1 = ()->System.out.println("engine started");//here we are storing a function (i.e annonymous function/lambda expression) inside a variable.
		c1.startEngine();
		
	}

}
-----------------------------
-> java provided some predefined functional interfaces.
1. Predicate:test(T t)
2. Suplier:get()
3. Consumer:accept(T t)
4. Function: apply(T t)

example:
import java.util.function.Predicate;

//class PredicateDemo {
//	public boolean test(int i) {
//		if (i % 2 == 0))
//		else
//			return false;
//	}
//}

public class LambdaExpressionExample2 {
	
	public static void main(String[] args) {
//		PredicateDemo pd = new PredicateDemo();
//		boolean result = pd.test(5);
//		System.out.println(result);
		
		//by using lambda expression and functional interface
		 Predicate<Integer> p = i -> i % 2 == 0;
		 System.out.println(p.test(10));
	}
	
}
-------------------------
Method Reference:
-----------------
-> Instead of using lamda expression, we can also use method reference.

example:
package com.InterviewPractice.example;

import java.util.List;
import java.util.function.Predicate;

// WAP to print student names starting with A.
public class LambdaExpressionAndMethodReferenceExample3 {

	public static boolean checkName(String name) {
		if (name.charAt(0) == 'A')
			return true;
		else
			return false;
	}

	public static void main(String[] args) {
		List<String> sl = List.of("Akash", "Bikash", "Kailash", "Anil", "Amrut");
//		Predicate<String> p=name->name.charAt(0)== 'A';
		Predicate<String> p = LambdaExpressionAndMethodReferenceExample3::checkName;//on static context
		
//		LambdaExpressionExample3 le = new LambdaExpressionExample3();//on non-static context(remove static keyword from checkName)
//		Predicate<String> p = le::checkName;

		for (String studentName : sl) {
			if (p.test(studentName))
				System.out.println(studentName);
		}

	}

}
-------------------------
Stream API:
------------
-> from java 1.8 onwards stream api came into picture.
-> we use collection to store data and we use stream api to process the data.
-> stream api has two type of operation to perform. 
	1. intermediate funcitons: map(), filter(), flatmap() etc..
	2. terminal functions: max(), min(), count() etc..
-> stream is like a flow of data which can be preocessed once only.
-> stream does not change/modify the data present in the collection.
-> map(): if we want to perform any task on each and every elements present inside a collection then we can use map().
-> filter(): if we want to preform some filter operation on a collection of data then we can use filter().
-> a stream can be created in two ways. 
	1. Stream.of() 
	2. <collectionType>.stream(), example: list.stream()
example:
package com.InterviewPractice.revision;

import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

//1. WAP to filter female employee.
//2. WAP to increment salary by 20,000 for each employee
//3. WAP to filter employees whose salary is more than 20,000
//4. WAP to filter employees whose name starts with R
//5. WAP to filter employees whose salary is between 20000 to 40000
//6. WAP to count employees whose name starts with R
//7. WAP to find whose salary is maximum
//8. WAP to find whose salary is minimum
//9. WAP to sort the employees according to their salary in descending order
class Employee{
	private String employeeName;
	private String employeeGender;
	private double employeeSalary;
	
	public Employee(String employeeName, String employeeGender, double employeeSalary ){
		super();
		this.employeeName=employeeName;
		this.employeeGender=employeeGender;
		this.employeeSalary=employeeSalary;
	}
	public String getEmployeeName() {
		return employeeName;
	}
	public void setEmployeeName(String employeeName) {
		this.employeeName = employeeName;
	}
	public String getEmployeeGender() {
		return employeeGender;
	}
	public void setEmployeeGender(String employeeGender) {
		this.employeeGender = employeeGender;
	}
	public double getEmployeeSalary() {
		return employeeSalary;
	}
	public void setEmployeeSalary(double employeeSalary) {
		this.employeeSalary = employeeSalary;
	}
	@Override
	public String toString() {
		return "Employee [employeeName=" + employeeName + ", employeeGender=" + employeeGender + ", employeeSalary="
				+ employeeSalary + "]";
	}
	
}
public class Example1 {

	public static void main(String[] args) {
		
Employee employee1 = new Employee("Raju", "Male", 10000.00);
//System.out.println(employee1.getEmployeeGender());
Employee employee2 = new Employee("Sita", "Female", 20000.00);
Employee employee3 = new Employee("Hari", "Male", 30000.00);
Employee employee4 = new Employee("Gita", "Female", 60000.00);
Employee employee5 = new Employee("Mita", "Female", 50000.00);
Employee employee6 = new Employee("Rahul", "Male", 70000.00);

List<Employee> employeeList= List.of(employee1, employee2, employee3, employee4, employee5, employee6);

	//1.
	//List<Employee> result = employeeList.stream().filter(e->e.getEmployeeGender()=="Female").collect(Collectors.toList());
	//System.out.println(result);
	
	//2.
	//employeeList.stream().map(e->e.getEmployeeSalary()+20000.00).collect(Collectors.toList()).forEach(System.out::println);
	
	//3.
	//employeeList.stream().filter(e->e.getEmployeeSalary()>20000.00).collect(Collectors.toList()).forEach(System.out::println);
	
	//4.

//	employeeList.stream()
//			.filter(e->e.getEmployeeName().charAt(0)=='R')
//			.collect(Collectors.toList())
//			.forEach(System.out::println);;
	
	//5.
	
//	List<Employee> result = employeeList.stream()
//			.filter(e->(e.getEmployeeSalary()>20000.00 && e.getEmployeeSalary()<40000.00))
//			.collect(Collectors.toList());
	//System.out.println(result);
	
	//6.
//	long count  = employeeList.stream()
//			.filter(e->e.getEmployeeName().charAt(0)=='R')
//			.count();
	//System.out.println(count);
	
	//7. 
	//Employee employeeWithMaxSalary = employeeList.stream().max((a,b)->(int)(a.getEmployeeSalary()-b.getEmployeeSalary())).get();
	//System.out.println(employeeWithMaxSalary);
	
	//8. 
	//Employee employeeWithMinSalary = employeeList.stream().min((a,b)->(int)(a.getEmployeeSalary()-b.getEmployeeSalary())).get();
	//System.out.println(employeeWithMinSalary);
	
	//9.
	List<Employee> result = employeeList.stream()
			.sorted(Comparator.comparing(Employee::getEmployeeSalary).reversed())
			.collect(Collectors.toList());
	result.forEach(System.out::println);
	}
}
-------------------------------------------------------------
Optional class:
---------------
-> Optional classes used for handling null.
-> if a method returns null value, then might be possible the upcoming method may get
	fail and will throw nullpointer exception. so to prevent this we can use optional class.
example:
-------
package com.InterviewPractice.example;

import java.util.Optional;

class Employee {
	private String employeeName;
	private String employeeGender;
	private double employeeSalary;

	public Employee(String employeeName, String employeeGender, double employeeSalary) {
		super();
		this.employeeName = employeeName;
		this.employeeGender = employeeGender;
		this.employeeSalary = employeeSalary;
	}

	public static Optional<Employee> getEmployee(String employeeName, String employeeGender, double employeeSalary) {
		// assuming data base logic written below and its fetching data from db
		return Optional.of(new Employee(employeeName, employeeGender, employeeSalary));
	}

	@Override
	public String toString() {
		return "Employee [employeeName=" + employeeName + ", employeeGender=" + employeeGender + ", employeeSalary="
				+ employeeSalary + "]";
	}
}

public class OptionalClassExample {
	public static void main(String[] args) {

		Optional<Employee> optionalEmployee = Employee.getEmployee("ram", "male", 25000.00);
		if (optionalEmployee.isEmpty() || optionalEmployee.isPresent())
			System.out.println(optionalEmployee.get());// getting the actual employee object as final result by using get()
	}
}
------------------------------------------------------------
-> After completing core java, we have seen collection framework, going forward in advance java there are JDBC, hibernate,servlet,JSP.
->In JDBC we are establishing the connection between java and database and storing data. But there is a problem, data can be stored in the form of values.
-> Apart from this, few more problems are there with JDBC, which are known as ORM problems. Those are:
 1. Problem of Relations
 2. Problem of inheritance
 3. Problem of navigation
 4. problem of grain
 5. problem of identity
-> To overcome these problem JPA standards has been specified. Any solution providers has to follow these standards.
-> Different vendors provided their solution to overcome these ORM problems, like- Ibatis, topLink, hibernate
-> By using hibernatte we can store objects into database.
->Servlets deals with web technology(old).
-> In JSP we can write java and html code in the same page.

SPRING FRAMEWORK:
--------------------
-> Framework is like a half developed project, which contains pre-defined configurations, dependencies, methods, classes etc.. 
   which helps us to develop our application faster. Ex: Spring framework, hibernate framework
-> Spring framework contains. 1. AOP 2.JDBC 3.ORM 4.JEE 5.MVC(WEB) 6.Spring core (IOC and DI)

SPRING CORE:
------------



